<!doctype html>
  <html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Interactive DnD Sheet</title>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9897771366732312" crossorigin="anonymous"></script>
    <style>
      :root {
        color-scheme: light;
        --bg: #f4f1ea;
        --fg: #2b1f17;
        --accent: #b84a2d;
        --panel: #fff7ee;
        --line: #2b1f17;
        --muted: #6b584a;
        --grid-cell: 156.499px;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Georgia", "Times New Roman", serif;
        background:
          radial-gradient(circle at 15% 10%, #fdf6ea 0%, transparent 45%),
          radial-gradient(circle at 85% 5%, #f7e6d1 0%, transparent 50%),
          var(--bg);
        color: var(--fg);
      }
      body.startup-modal-open > *:not(.startup-modal-overlay):not(script) {
        filter: blur(8px);
        pointer-events: none;
        user-select: none;
      }
      body.ability-picker-modal-open > *:not(.ability-picker):not(.item-panel):not(script) {
        pointer-events: none;
        user-select: none;
      }
      body.race-picker-modal-open > *:not(.race-picker):not(.item-panel):not(script) {
        pointer-events: none;
        user-select: none;
      }
      body.class-picker-modal-open > *:not(.class-picker):not(.item-panel):not(script) {
        pointer-events: none;
        user-select: none;
      }
      body.subclass-picker-modal-open > *:not(.alignment-picker):not(.item-panel):not(script) {
        pointer-events: none;
        user-select: none;
      }
      body.background-picker-modal-open > *:not(.background-picker):not(.item-panel):not(script) {
        pointer-events: none;
        user-select: none;
      }
      body.background-config-modal-open > *:not(.background-config-picker):not(.item-panel):not(script) {
        pointer-events: none;
        user-select: none;
      }
      .startup-modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(25, 18, 13, 0.45);
        display: grid;
        place-items: center;
        padding: 16px;
        z-index: 3000;
      }
      .startup-modal-overlay[aria-hidden="true"] {
        display: none;
      }
      .startup-modal {
        width: min(520px, 100%);
        border: 2px solid var(--line);
        border-radius: 18px;
        background: #fff;
        box-shadow: 0 18px 40px rgba(43, 31, 23, 0.3);
        padding: 20px;
      }
      .startup-modal-title {
        margin: 0 0 8px;
        font-size: clamp(1.4rem, 2vw, 1.8rem);
        text-transform: uppercase;
        letter-spacing: 0.06em;
        text-align: center;
      }
      .startup-modal-copy {
        margin: 0 0 16px;
        color: var(--muted);
        text-align: center;
      }
      .startup-modal-actions {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
      }
      .startup-modal-btn {
        border: 2px solid var(--line);
        border-radius: 12px;
        padding: 12px;
        background: #fff;
        color: var(--fg);
        cursor: pointer;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }
      .startup-modal-btn:hover,
      .startup-modal-btn:focus-visible {
        background: #f3e5d4;
        outline: none;
      }
      .startup-modal-btn-primary {
        background: var(--accent);
        color: #fff;
      }
      .startup-modal-btn-primary:hover,
      .startup-modal-btn-primary:focus-visible {
        background: #9d3f25;
      }
      @media (max-width: 560px) {
        .startup-modal-actions {
          grid-template-columns: 1fr;
        }
      }
      .page {
        max-width: 1200px;
        margin: 24px auto 60px;
        padding: 0 16px 32px;
      }
      .title {
        text-align: center;
        font-size: clamp(2rem, 3vw, 2.8rem);
        letter-spacing: 0.12em;
        text-transform: uppercase;
        margin: 8px 0 18px;
      }
      .layout {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 18px;
        align-items: start;
        justify-items: center;
      }
      .sheet {
        background: var(--panel);
        border: 2px solid var(--line);
        border-radius: 18px;
        padding: 18px;
        box-shadow: 0 18px 40px rgba(43, 31, 23, 0.18);
        width: calc((var(--grid-cell) * 6) + (12px * 5) + 36px);
        max-width: 100%;
      }
      .header-grid {
        position: relative;
      }
      .grid-debug {
        position: absolute;
        inset: 0;
        display: grid;
        grid-template-columns: var(--grid-cell) calc(var(--grid-cell) * 1.05) repeat(4, var(--grid-cell));
        grid-template-rows: calc(var(--grid-cell) / 3) calc(var(--grid-cell) / 3) repeat(12, calc(var(--grid-cell) / 2)) calc(var(--grid-cell) / 3);
        gap: 12px;
        pointer-events: none;
        font-size: 10px;
        color: rgba(107, 88, 74, 0.8);
        z-index: 0;
      }
      .grid-debug span {
        display: grid;
        place-items: center;
        border: 1px dashed rgba(107, 88, 74, 0.25);
      }
      .header-grid > .panel,
      .header-grid > .section-stack,
      .header-grid > .ability {
        position: relative;
        z-index: 1;
        width: 100%;
        height: 100%;
        font-size: 0.75rem;
      }
      .stats-column {
        display: grid;
        grid-template-columns: 1fr;
        grid-auto-rows: min-content;
        row-gap: 8px;
        grid-column: 2 / 3;
        grid-row: 7 / 15;
      }
      .skills-column {
        grid-column: 2 / 7;
        grid-row: 2 / -1;
      }
      .header-grid {
        display: grid;
        grid-template-columns: var(--grid-cell) calc(var(--grid-cell) * 1.05) repeat(4, var(--grid-cell));
        grid-template-rows: calc(var(--grid-cell) / 3) calc(var(--grid-cell) / 3) repeat(12, calc(var(--grid-cell) / 2)) calc(var(--grid-cell) / 3);
        gap: 12px;
        margin-bottom: 16px;
      }
      .grid-character-name {
        grid-column: 1 / 3;
        grid-row: 1 / 2;
      }
      .grid-class {
        grid-column: 4 / 5;
        grid-row: 1 / 2;
      }
      .grid-armor-class {
        grid-column: 3 / 4;
        grid-row: 3 / 4;
      }
      .grid-initiative {
        grid-column: 4 / 5;
        grid-row: 3 / 4;
        width: 50%;
        justify-self: start;
      }
      .grid-speed {
        grid-column: 6 / 7;
        grid-row: 1 / 2;
      }
      .grid-passive-wisdom {
        grid-column: 1 / 3;
        grid-row: 15 / 16;
      }
      .grid-equipment {
        grid-column: 3 / 5;
        grid-row: 5 / 12;
      }
      .grid-spells {
        grid-column: 5 / 7;
        grid-row: 5 / 12;
      }
      .grid-items {
        grid-column: 3 / 7;
        grid-row: 12 / 16;
      }
      .grid-level {
        grid-column: 1 / 2;
        grid-row: 2 / 3;
      }
      .grid-size {
        grid-column: 3 / 4;
        grid-row: 2 / 3;
      }
      .grid-inspiration {
        grid-column: 2 / 3;
        grid-row: 3 / 4;
      }
      .grid-health {
        grid-column: 3 / 5;
        grid-row: 4 / 5;
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
      }
      .ac-options {
        margin-top: 6px;
        display: none;
      }
      .grid-race {
        grid-column: 3 / 4;
        grid-row: 1 / 2;
      }
      .grid-alignment {
        grid-column: 4 / 5;
        grid-row: 2 / 3;
      }
      .grid-background {
        grid-column: 5 / 6;
        grid-row: 1 / 2;
      }
      .grid-proficiencies {
        grid-column: 5 / 6;
        grid-row: 2 / 4;
      }
      .grid-resistance {
        grid-column: 5 / 6;
        grid-row: 4 / 5;
      }
      .grid-traits {
        grid-column: 6 / 7;
        grid-row: 2 / 5;
      }
      .grid-exp {
        grid-column: 2 / 3;
        grid-row: 2 / 3;
      }
      .grid-proficiency {
        grid-column: 2 / 3;
        grid-row: 4 / 5;
      }
      .grid-saving-throws {
        grid-column: 2 / 3;
        grid-row: 5 / 7;
      }
      .grid-skills {
        grid-column: 2 / 3;
        grid-row: 7 / 15;
        font-size: 0.6rem;
        height: auto;
        display: flex;
        flex-direction: column;
      }
      .panel {
        position: relative;
        border: 2px solid var(--line);
        border-radius: 14px;
        padding: 10px;
        background: #fff;
        width: 100%;
        height: 100%;
        overflow: visible;
      }
      .panel-label {
        position: absolute;
        top: -12px;
        left: 50%;
        transform: translateX(-50%);
        padding: 2px 8px;
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        white-space: nowrap;
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 999px;
        text-align: center;
      }
      .panel input,
      .panel textarea,
      .panel select {
        width: 100%;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        padding: 6px 8px;
        font-family: inherit;
        font-size: 0.98rem;
        background: #fff;
        height: 100%;
      }
      .panel .panel-display {
        width: 100%;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        padding: 6px 8px;
        font-family: inherit;
        font-size: 0.98rem;
        background: #f6f1e8;
        color: #4b3a2f;
        height: 100%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
      }
      .level-control {
        display: flex;
        align-items: center;
        gap: 6px;
        width: 100%;
      }
      .level-control .panel-display {
        flex: 1;
      }
      .level-adjust {
        width: 28px;
        min-width: 28px;
        height: 28px;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        background: #f6f1e8;
        color: #4b3a2f;
        font-family: inherit;
        font-size: 1rem;
        line-height: 1;
        cursor: pointer;
      }
      .text-center {
        text-align: center;
      }
      .trait-list {
        margin: 0;
        padding: 0 0 0 16px;
        height: 100%;
        overflow: auto;
      }
      .trait-list li {
        margin: 0 0 6px;
      }
      .trait-clickable {
        cursor: pointer;
      }
      .trait-clickable:hover {
        text-decoration: underline;
      }
      .tabs {
        display: grid;
        grid-template-rows: auto 1fr;
        gap: 6px;
        width: 100%;
        height: 100%;
      }
      .tab-panels {
        height: 100%;
      }
      .tab-buttons {
        display: grid;
        grid-template-columns: repeat(10, minmax(0, 1fr));
        gap: 4px;
        text-align: center;
        margin-top: 20px;
      }
      .tab-buttons label {
        display: block;
        text-align: center;
        padding: 4px 6px;
        border: 1px solid #cdbba8;
        border-radius: 6px;
        background: #fff;
        cursor: pointer;
        font-size: 0.7rem;
      }
      .tab-panel {
        display: none;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        padding: 6px;
        background: #fff;
        height: 100%;
        overflow: auto;
      }
      .grid-equipment {
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      .grid-equipment .panel-label {
        top: 8px;
      }
      .grid-equipment .actions {
        margin-top: 20px;
        flex: 0 0 auto;
      }
      .grid-spells .panel-label {
        top: 8px;
      }
      .grid-spells {
        overflow: hidden;
      }
      #equipment-list {
        max-height: 100%;
        flex: 1 1 auto;
        min-height: 0;
        overflow: auto;
      }
      .tab-actions {
        display: flex;
        gap: 6px;
        justify-content: flex-end;
        align-items: center;
      }
      .tab-actions button {
        padding: 4px 8px;
        border-radius: 6px;
        border: 1px solid #2b1f17;
        background: #fff;
        font-family: inherit;
        font-size: 0.7rem;
        cursor: pointer;
      }
      .tab-input {
        position: absolute;
        opacity: 0;
        pointer-events: none;
      }
      #spell-tab-1:checked ~ .tab-buttons label[for="spell-tab-1"],
      #spell-tab-2:checked ~ .tab-buttons label[for="spell-tab-2"],
      #spell-tab-3:checked ~ .tab-buttons label[for="spell-tab-3"],
      #spell-tab-4:checked ~ .tab-buttons label[for="spell-tab-4"],
      #spell-tab-5:checked ~ .tab-buttons label[for="spell-tab-5"],
      #spell-tab-6:checked ~ .tab-buttons label[for="spell-tab-6"],
      #spell-tab-7:checked ~ .tab-buttons label[for="spell-tab-7"],
      #spell-tab-8:checked ~ .tab-buttons label[for="spell-tab-8"],
      #spell-tab-9:checked ~ .tab-buttons label[for="spell-tab-9"],
      #spell-tab-10:checked ~ .tab-buttons label[for="spell-tab-10"] {
        background: #f6f1e8;
        border-color: #2b1f17;
      }
      #spell-tab-1:checked ~ .tab-panels #spell-panel-1,
      #spell-tab-2:checked ~ .tab-panels #spell-panel-2,
      #spell-tab-3:checked ~ .tab-panels #spell-panel-3,
      #spell-tab-4:checked ~ .tab-panels #spell-panel-4,
      #spell-tab-5:checked ~ .tab-panels #spell-panel-5,
      #spell-tab-6:checked ~ .tab-panels #spell-panel-6,
      #spell-tab-7:checked ~ .tab-panels #spell-panel-7,
      #spell-tab-8:checked ~ .tab-panels #spell-panel-8,
      #spell-tab-9:checked ~ .tab-panels #spell-panel-9,
      #spell-tab-10:checked ~ .tab-panels #spell-panel-10 {
        display: block;
      }
      .panel input[readonly] {
        background: #f6f1e8;
        color: #4b3a2f;
      }
      textarea {
        min-height: 110px;
        resize: vertical;
      }
      .ability {
        border: 2px solid var(--line);
        border-radius: 16px;
        padding: 8px;
        background: #fff;
        text-align: center;
        width: 100%;
        height: 100%;
        margin: 0;
      }
      .ability-strength {
        grid-column: 1 / 2;
        grid-row: 3 / 5;
      }
      .ability-dexterity {
        grid-column: 1 / 2;
        grid-row: 5 / 7;
      }
      .ability-constitution {
        grid-column: 1 / 2;
        grid-row: 7 / 9;
      }
      .ability-intelligence {
        grid-column: 1 / 2;
        grid-row: 9 / 11;
      }
      .ability-wisdom {
        grid-column: 1 / 2;
        grid-row: 11 / 13;
      }
      .ability-charisma {
        grid-column: 1 / 2;
        grid-row: 13 / 15;
      }
      .ability h3 {
        margin: 0 0 8px;
        font-size: 0.85rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }
      .ability .ability-row {
        display: grid;
        grid-template-rows: auto auto;
        gap: 6px;
        justify-items: center;
      }
      .ability input,
      .ability .ability-score-display {
        text-align: center;
        font-size: 1.05rem;
      }
      .ability input[type="number"] {
        width: 64px;
      }
      .ability .ability-score-display {
        width: 64px;
        min-height: 32px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        background: #f6f1e8;
        color: #4b3a2f;
      }
      .ability .ability-mod-display {
        width: 40px;
        min-height: 32px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        background: #f6f1e8;
        color: #4b3a2f;
      }
      .ability input[readonly] {
        width: 40px;
      }
      .rollable {
        cursor: pointer;
      }
      .rollable:hover {
        text-decoration: underline;
      }
      .list {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .grid-saving-throws .list {
        gap: 0.5px;
        margin-top: 20px;
      }
      .grid-saving-throws input[type="checkbox"] {
        pointer-events: none;
      }
      .grid-skills .list {
        gap: 3px;
      }
      .list-item {
        display: grid;
        grid-template-columns: 18px 1fr 58px;
        align-items: center;
        gap: 6px;
        position: relative;
      }
      .list-value {
        display: inline-block;
        width: 58px;
        text-align: center;
        padding: 2px 4px;
        font-variant-numeric: tabular-nums;
      }
      .list-item.rollable-row {
        cursor: pointer;
      }
      .list-item.rollable-row span,
      .list-item.rollable-row input[type="text"],
      .list-item.rollable-row input[readonly] {
        cursor: pointer;
      }
      .list-item input[type="number"],
      .list-item input[type="text"] {
        width: 58px;
        text-align: center;
        padding: 4px 4px;
      }
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }
      .small-input {
        text-align: center;
      }
      .section-stack {
        display: grid;
        gap: 12px;
      }
      }
      .dice-panel {
        position: fixed;
        left: 16px;
        bottom: 16px;
        width: min(320px, 90vw);
        z-index: 999;
        background: #fff;
        border: 2px solid var(--line);
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 12px 24px rgba(43, 31, 23, 0.15);
      }
      .sticky-roll {
        position: fixed;
        left: 16px;
        bottom: 16px;
        z-index: 1000;
        padding: 10px 14px;
        border: 2px solid var(--line);
        border-radius: 12px;
        background: #fff;
        font-size: 0.95rem;
        box-shadow: 0 10px 20px rgba(43, 31, 23, 0.15);
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
        transform: translateY(0);
        transition: opacity 0.24s ease, transform 0.24s ease, visibility 0.24s ease;
      }
      .sticky-roll.banished {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transform: translateY(14px);
      }
      .sticky-roll-title {
        margin: 0 0 8px;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--muted);
      }
      .dice-title {
        margin: 0 0 12px;
        font-size: 0.95rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--muted);
      }
      #roll-btn {
        padding: 10px 18px;
        font-size: 1rem;
        font-family: inherit;
        border-radius: 12px;
        border: 2px solid var(--line);
        background: var(--accent);
        color: #fff;
        cursor: pointer;
      }
      #roll-result {
        margin-top: 10px;
        font-size: 1rem;
        display: grid;
        gap: 6px;
      }
      .roll-line {
        display: flex;
        justify-content: space-between;
        gap: 8px;
      }
      .roll-total {
        margin-top: 6px;
        padding-top: 6px;
        border-top: 1px solid #cdbba8;
        font-weight: 700;
        text-align: right;
      }
      .actions {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
      }
      .actions select,
      .actions button {
        padding: 6px 10px;
        border-radius: 10px;
        border: 2px solid var(--line);
        font-family: inherit;
        background: #fff;
      }
      .actions .active-weapon {
        font-size: 0.9rem;
        color: var(--muted);
      }
      .actions .equip-status {
        font-size: 0.85rem;
        color: var(--accent);
      }
      #add-weapon {
        background: var(--accent);
        color: #fff;
        cursor: pointer;
      }
      #attack-roll {
        background: #2f3a4a;
        color: #fff;
        cursor: pointer;
      }
      .hit-option {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 0.9rem;
        color: var(--muted);
      }
      #equipment-list {
        display: grid;
        gap: 6px;
      }
      .equipment-item {
        display: grid;
        grid-template-columns: auto 1fr auto;
        align-items: center;
        gap: 8px;
        padding: 6px 8px;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        background: #fff;
      }
      .equipment-item.active {
        border-color: var(--accent);
        box-shadow: 0 0 0 1px rgba(184, 74, 45, 0.15);
      }
      .equip-btn {
        padding: 4px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #c23a2b;
        color: #fff;
        cursor: pointer;
        font-size: 0.85rem;
      }
      .equip-btn.equipped {
        background: #2b63c2;
      }
      .equip-badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: #f6f1e8;
        font-size: 0.75rem;
        color: var(--muted);
      }
      .twohand-btn {
        padding: 4px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #f1efe7;
        color: var(--fg);
        cursor: pointer;
        font-size: 0.8rem;
      }
      .twohand-btn.active {
        background: #2b63c2;
        color: #fff;
      }
      .twohand-btn[disabled] {
        cursor: not-allowed;
        opacity: 0.6;
      }
      .equipment-dmg {
        padding: 4px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #f6f1e8;
        cursor: pointer;
      }
      .equipment-remove {
        width: 26px;
        height: 26px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        color: #a02a20;
        font-weight: 700;
        line-height: 1;
        cursor: pointer;
      }
      .item-panel {
        position: fixed;
        right: 16px;
        top: 16px;
        width: min(360px, 92vw);
        max-height: calc(100vh - 32px);
        overflow: auto;
        z-index: 1001;
        background: #fff;
        border: 2px solid var(--line);
        border-radius: 16px;
        padding: 16px 16px 18px;
        box-shadow: 0 16px 30px rgba(43, 31, 23, 0.2);
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transform: translateX(18px);
        transition: opacity 0.24s ease, transform 0.24s ease, visibility 0.24s ease;
      }
      .item-panel.open {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
        transform: translateX(0);
      }
      .item-panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 10px;
      }
      .item-panel-title {
        margin: 0;
        font-size: 1.1rem;
      }
      .item-panel-close {
        border: 2px solid var(--line);
        background: #fff;
        width: 32px;
        height: 32px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 1rem;
        line-height: 1;
      }
      .item-panel-close:hover {
        background: #f6f1e8;
      }
      .item-panel-body {
        display: grid;
        gap: 8px;
        color: var(--fg);
      }
      .item-row {
        display: grid;
        grid-template-columns: 120px 1fr;
        gap: 8px;
        align-items: baseline;
        font-size: 0.95rem;
      }
      .item-row strong {
        font-weight: 700;
        color: var(--muted);
      }
      .item-tooltip {
        position: relative;
        cursor: help;
      }
      .item-tooltip::after {
        content: attr(data-tooltip);
        position: absolute;
        left: 0;
        top: 100%;
        margin-top: 6px;
        min-width: 160px;
        max-width: 280px;
        padding: 8px 10px;
        border-radius: 10px;
        background: #1f1711;
        color: #fff7ee;
        font-size: 0.82rem;
        line-height: 1.25;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        opacity: 0;
        pointer-events: none;
        transform: translateY(-4px);
        transition: opacity 0.15s ease, transform 0.15s ease;
        z-index: 5;
        white-space: normal;
      }
      .item-tooltip:hover::after {
        opacity: 1;
        transform: translateY(0);
      }
      .weapon-picker {
        position: fixed;
        left: 16px;
        top: 16px;
        width: min(360px, 92vw);
        max-height: calc(100vh - 32px);
        overflow: auto;
        z-index: 1002;
        background: #fff;
        border: 2px solid var(--line);
        border-radius: 16px;
        padding: 14px;
        box-shadow: 0 16px 30px rgba(43, 31, 23, 0.2);
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transform: translateX(-18px);
        transition: opacity 0.24s ease, transform 0.24s ease, visibility 0.24s ease;
      }
      .weapon-picker.open {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
        transform: translateX(0);
      }
      .ability-picker .weapon-picker-header {
        grid-template-columns: 1fr auto;
      }
      .ability-picker {
        left: 50%;
        top: 50%;
        width: min(560px, calc(100vw - 32px));
        max-height: min(700px, calc(100vh - 32px));
        transform: translate(-50%, -50%) scale(0.98);
        z-index: 3500;
      }
      .ability-picker.open {
        transform: translate(-50%, -50%) scale(1);
      }
      .ability-picker .picker-title {
        font-weight: 700;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        font-size: 0.78rem;
        color: var(--muted);
        text-align: center;
      }
      .ability-picker.locked #ability-picker-close {
        display: none;
      }
      .race-picker.locked #race-picker-close {
        display: none;
      }
      .class-picker.locked #class-picker-close {
        display: none;
      }
      .alignment-picker.locked #alignment-picker-close {
        display: none;
      }
      .background-picker.locked #background-picker-close {
        display: none;
      }
      .background-config-picker.locked #background-config-close {
        display: none;
      }
      .ability-picker .ability-values,
      .ability-picker .ability-choices {
        display: grid;
        gap: 8px;
        margin-bottom: 12px;
      }
      .ability-picker .ability-options {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 8px;
        margin-bottom: 12px;
      }
      .ability-picker .ability-values {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
      .ability-picker .ability-choices {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .ability-picker button {
        padding: 8px 10px;
        border-radius: 10px;
        border: 2px solid var(--line);
        background: #fff;
        font-family: inherit;
        cursor: pointer;
      }
      .ability-picker button.selected {
        border-color: var(--accent);
        background: #fff4ec;
      }
      .ability-picker button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .background-config-picker .weapon-picker-header {
        grid-template-columns: 1fr auto auto;
      }
      .background-config-body {
        display: grid;
        gap: 12px;
      }
      .background-config-section {
        border: 1px solid #d8c7b5;
        border-radius: 10px;
        padding: 10px;
        background: #fffaf5;
      }
      .background-config-section h4 {
        margin: 0 0 8px;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: var(--muted);
      }
      .background-choice-row {
        display: grid;
        gap: 8px;
        margin-bottom: 8px;
      }
      .background-choice-row label {
        font-size: 0.82rem;
      }
      .background-choice-row select {
        width: 100%;
        padding: 6px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        font-family: inherit;
        background: #fff;
      }
      .background-mode-options {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
        margin-bottom: 10px;
      }
      .background-mode-options button {
        padding: 8px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        font-family: inherit;
        cursor: pointer;
      }
      .background-mode-options button.selected {
        border-color: var(--accent);
        background: #fff4ec;
      }
      .background-static-list {
        margin: 0;
        padding-left: 18px;
        font-size: 0.85rem;
      }
      .background-static-list li {
        margin-bottom: 4px;
      }
      .class-equipment-picker .weapon-picker-header {
        grid-template-columns: 1fr auto auto;
      }
      .class-equipment-body {
        display: grid;
        gap: 12px;
      }
      .class-equipment-row {
        border: 1px solid #d8c7b5;
        border-radius: 10px;
        padding: 10px;
        background: #fffaf5;
        display: grid;
        gap: 8px;
      }
      .class-equipment-row h4 {
        margin: 0;
        font-size: 0.8rem;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .class-equipment-row select {
        width: 100%;
        padding: 6px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        font-family: inherit;
        background: #fff;
      }
      .weapon-picker-header {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 8px;
        align-items: center;
        margin-bottom: 12px;
      }
      .weapon-picker .weapon-picker-header {
        position: sticky;
        top: 0;
        z-index: 2;
        background: #fff;
        padding-bottom: 8px;
      }
      .size-picker .weapon-picker-header {
        grid-template-columns: 1fr auto;
      }
      .size-picker .picker-title {
        font-weight: 700;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        font-size: 0.78rem;
        color: var(--muted);
      }
      .alignment-picker .weapon-picker-header {
        grid-template-columns: 1fr auto auto;
      }
      .weapon-picker-header input {
        width: 100%;
        border: 1px solid #cdbba8;
        border-radius: 10px;
        padding: 6px 10px;
        font-family: inherit;
      }
      .weapon-picker-add,
      .weapon-picker-close {
        border-radius: 10px;
        border: 2px solid var(--line);
        padding: 6px 12px;
        font-family: inherit;
        cursor: pointer;
      }
      .weapon-picker-add {
        background: var(--accent);
        color: #fff;
      }
      .weapon-picker-close {
        background: #fff;
      }
      .weapon-category {
        margin: 10px 0 6px;
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
      }
      .weapon-list {
        display: grid;
        gap: 6px;
      }
      .weapon-option {
        border: 1px solid #cdbba8;
        border-radius: 10px;
        padding: 8px 10px;
        cursor: pointer;
        background: #fff;
      }
      .weapon-option strong {
        display: block;
        font-size: 0.95rem;
      }
      .weapon-option span {
        font-size: 0.82rem;
        color: var(--muted);
      }
      .weapon-option.selected {
        border-color: var(--accent);
        background: #fff4ec;
      }
      .spell-list {
        display: grid;
        gap: 6px;
      }
      .spell-list-anchor {
        width: 12px;
        height: 12px;
        border: 2px solid var(--line);
        border-radius: 2px;
        background: #fff;
      }
      .spell-slot-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: flex-start;
      }
      .spell-item {
        display: grid;
        grid-template-columns: 1fr auto;
        align-items: center;
        gap: 8px;
        padding: 6px 8px;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        background: #fff;
      }
      .spell-item-actions {
        display: inline-flex;
        gap: 6px;
        align-items: center;
      }
      .spell-item strong {
        display: block;
        font-size: 0.95rem;
      }
      .spell-meta {
        font-size: 0.8rem;
        color: var(--muted);
      }
      .spell-roll {
        padding: 4px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #2f3a4a;
        color: #fff;
        cursor: pointer;
        font-size: 0.75rem;
      }
      .spell-remove {
        padding: 4px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #c23a2b;
        color: #fff;
        cursor: pointer;
        font-size: 0.75rem;
      }
      .grid-items {
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-height: 0;
      }
      #add-item {
        background: var(--accent);
        color: #fff;
        cursor: pointer;
      }
      #items-list {
        display: grid;
        gap: 6px;
        max-height: 100%;
        overflow: auto;
      }
      .inventory-header,
      .inventory-row {
        display: grid;
        grid-template-columns: 140px minmax(0, 1fr) 80px auto;
        gap: 8px;
        align-items: start;
      }
      .inventory-header.with-qty,
      .inventory-row.with-qty {
        grid-template-columns: 120px minmax(0, 1fr) 80px 52px 76px auto;
      }
      .inventory-header {
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--muted);
        padding: 0 4px;
        position: sticky;
        top: 0;
        z-index: 1;
        background: #f6f1e8;
        border-radius: 6px;
      }
      .inventory-row {
        border: 1px solid #cdbba8;
        border-radius: 8px;
        padding: 6px 8px;
        background: #fff;
        font-size: 0.9rem;
      }
      .inventory-name {
        font-weight: 700;
        cursor: pointer;
      }
      .inventory-desc {
        color: var(--muted);
        white-space: normal;
        overflow-wrap: anywhere;
      }
      .inventory-gold,
      .inventory-qty {
        text-align: center;
      }
      .inventory-remove {
        padding: 4px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #c23a2b;
        color: #fff;
        cursor: pointer;
        font-size: 0.75rem;
      }
      .inventory-remove-qty {
        width: 100%;
        min-width: 0;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        padding: 4px 6px;
        font-family: inherit;
        font-size: 0.8rem;
        text-align: center;
      }
      @media (max-width: 960px) {
        .layout {
          grid-template-columns: 1fr;
        }
        .header-grid {
          grid-template-columns: 1fr;
        }
        .stats-grid {
          grid-template-columns: 1fr;
        }
        .dice-panel {
          left: 12px;
          bottom: 12px;
          width: min(360px, 94vw);
        }
        .item-panel {
          right: 12px;
          top: 12px;
        }
        .weapon-picker {
          left: 12px;
          top: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <div class="title">Interactive DnD Sheet</div>
      <div class="layout">
        <section class="sheet" aria-label="Character Sheet">
          <div class="header-grid">
            <div class="grid-debug">
              <span>1</span>
              <span>2</span>
              <span>3</span>
              <span>4</span>
              <span>5</span>
              <span>6</span>
              <span>7</span>
              <span>8</span>
              <span>9</span>
              <span>10</span>
              <span>11</span>
              <span>12</span>
              <span>13</span>
              <span>14</span>
              <span>15</span>
              <span>16</span>
              <span>17</span>
              <span>18</span>
              <span>19</span>
              <span>20</span>
              <span>21</span>
              <span>22</span>
              <span>23</span>
              <span>24</span>
              <span>25</span>
              <span>26</span>
              <span>27</span>
              <span>28</span>
              <span>29</span>
              <span>30</span>
              <span>31</span>
              <span>32</span>
              <span>33</span>
              <span>34</span>
              <span>35</span>
              <span>36</span>
              <span>37</span>
              <span>38</span>
              <span>39</span>
              <span>40</span>
              <span>41</span>
              <span>42</span>
              <span>43</span>
              <span>44</span>
              <span>45</span>
              <span>46</span>
              <span>47</span>
              <span>48</span>
              <span>49</span>
              <span>50</span>
              <span>51</span>
              <span>52</span>
              <span>53</span>
              <span>54</span>
              <span>55</span>
              <span>56</span>
              <span>57</span>
              <span>58</span>
              <span>59</span>
              <span>60</span>
              <span>61</span>
              <span>62</span>
              <span>63</span>
              <span>64</span>
              <span>65</span>
              <span>66</span>
              <span>67</span>
              <span>68</span>
              <span>69</span>
              <span>70</span>
              <span>71</span>
              <span>72</span>
              <span>73</span>
              <span>74</span>
              <span>75</span>
              <span>76</span>
              <span>77</span>
              <span>78</span>
              <span>79</span>
              <span>80</span>
              <span>81</span>
              <span>82</span>
              <span>83</span>
              <span>84</span>
              <span>85</span>
              <span>86</span>
              <span>87</span>
              <span>88</span>
              <span>89</span>
              <span>90</span>
            </div>

            <div class="panel grid-character-name">
              <div class="panel-label">Character Name</div>
              <input id="character-name" type="text" class="text-center" />
            </div>
            <div class="panel grid-class">
              <div class="panel-label">Class</div>
              <input id="class-level" type="text" />
            </div>
            <div class="panel grid-armor-class">
              <div class="panel-label">Armor Class</div>
              <span id="armor-class" class="panel-display text-center"></span>
            </div>
            <div class="panel grid-initiative">
              <div class="panel-label">Initiative</div>
              <span id="initiative" class="panel-display text-center rollable" role="button" tabindex="0"></span>
            </div>
            <div class="panel grid-speed">
              <div class="panel-label">Speed</div>
              <span id="speed" class="panel-display text-center"></span>
            </div>
            <div class="panel grid-passive-wisdom">
              <div class="panel-label">PASSIVE WISDOM (PERCEPTION)</div>
              <span id="passive-wisdom-perception" class="panel-display text-center"></span>
            </div>
            <div class="panel grid-level">
              <div class="panel-label">Level</div>
              <div class="level-control">
                <button id="level-decrease" class="level-adjust" type="button" aria-label="Decrease level">-</button>
                <span id="level" class="panel-display text-center"></span>
                <button id="level-increase" class="level-adjust" type="button" aria-label="Increase level">+</button>
              </div>
            </div>
            <div class="panel grid-size">
              <div class="panel-label">Size</div>
              <input id="size" type="text" readonly inputmode="none" />
            </div>
            <div class="panel grid-inspiration">
              <div class="panel-label">Inspiration</div>
              <input id="inspiration" type="text" />
            </div>
            <div class="panel grid-health">
              <div class="panel-label">Health</div>
              <div class="panel">
                <input id="current-hp" type="number" min="0" />
              </div>
              <div class="panel">
                <span id="total-hp" class="panel-display text-center"></span>
              </div>
            </div>
            <div class="panel grid-race">
              <div class="panel-label">Race</div>
              <input id="race" type="text" />
            </div>
            <div class="panel grid-alignment">
              <div class="panel-label">Subclass</div>
              <input id="subclass" type="text" />
            </div>
            <div class="panel grid-background">
              <div class="panel-label">Background</div>
              <input id="background" type="text" />
            </div>
            <div class="panel grid-proficiencies">
              <div class="panel-label">Proficiencies</div>
              <ul id="proficiencies" class="trait-list" aria-live="polite"></ul>
            </div>
            <div class="panel grid-resistance">
              <div class="panel-label">Resistance</div>
              <ul id="resistance" class="trait-list" aria-live="polite"></ul>
            </div>
            <div class="panel grid-traits">
              <div class="panel-label">Feats and Traits</div>
              <ul id="traits" class="trait-list" aria-live="polite"></ul>
            </div>
            <div class="panel grid-exp">
              <div class="panel-label">EXP</div>
              <span id="xp" class="panel-display text-center"></span>
            </div>
            <div class="panel grid-proficiency">
              <div class="panel-label">Proficiency Bonus</div>
              <input id="proficiency-bonus" type="text" readonly class="text-center" />
            </div>
            <div class="panel grid-saving-throws">
              <div class="panel-label">Saving Throws</div>
              <div class="list">
                <div class="list-item" data-ability="str"><input id="save-str-prof" type="checkbox" /><span>Strength</span><span class="save-value list-value">+0</span></div>
                <div class="list-item" data-ability="dex"><input id="save-dex-prof" type="checkbox" /><span>Dexterity</span><span class="save-value list-value">+0</span></div>
                <div class="list-item" data-ability="con"><input id="save-con-prof" type="checkbox" /><span>Constitution</span><span class="save-value list-value">+0</span></div>
                <div class="list-item" data-ability="int"><input id="save-int-prof" type="checkbox" /><span>Intelligence</span><span class="save-value list-value">+0</span></div>
                <div class="list-item" data-ability="wis"><input id="save-wis-prof" type="checkbox" /><span>Wisdom</span><span class="save-value list-value">+0</span></div>
                <div class="list-item" data-ability="cha"><input id="save-cha-prof" type="checkbox" /><span>Charisma</span><span class="save-value list-value">+0</span></div>
              </div>
            </div>
            <div class="ability ability-strength" data-ability="str">
              <h3>Strength</h3>
              <div class="ability-row">
                <span id="str-score" class="ability-score-display"></span>
                <span id="str-mod" class="ability-mod-display"></span>
              </div>
            </div>
            <div class="ability ability-dexterity" data-ability="dex">
              <h3>Dexterity</h3>
              <div class="ability-row">
                <span id="dex-score" class="ability-score-display"></span>
                <span id="dex-mod" class="ability-mod-display"></span>
              </div>
            </div>
            <div class="ability ability-constitution" data-ability="con">
              <h3>Constitution</h3>
              <div class="ability-row">
                <span id="con-score" class="ability-score-display"></span>
                <span id="con-mod" class="ability-mod-display"></span>
              </div>
            </div>
            <div class="ability ability-intelligence" data-ability="int">
              <h3>Intelligence</h3>
              <div class="ability-row">
                <span id="int-score" class="ability-score-display"></span>
                <span id="int-mod" class="ability-mod-display"></span>
              </div>
            </div>
            <div class="ability ability-wisdom" data-ability="wis">
              <h3>Wisdom</h3>
              <div class="ability-row">
                <span id="wis-score" class="ability-score-display"></span>
                <span id="wis-mod" class="ability-mod-display"></span>
              </div>
            </div>
            <div class="ability ability-charisma" data-ability="cha">
              <h3>Charisma</h3>
              <div class="ability-row">
                <span id="cha-score" class="ability-score-display"></span>
                <span id="cha-mod" class="ability-mod-display"></span>
              </div>
            </div>
          
            <div class="panel grid-skills">
              <div class="panel-label">Skills</div>
              <div class="list">
                  <div class="list-item" data-ability="dex"><input id="skill-acrobatics-prof" type="checkbox" /><span>Acrobatics (Dex)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="wis"><input id="skill-animal-handling-prof" type="checkbox" /><span>Animal Handling (Wis)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="int"><input id="skill-arcana-prof" type="checkbox" /><span>Arcana (Int)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="str"><input id="skill-athletics-prof" type="checkbox" /><span>Athletics (Str)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="cha"><input id="skill-deception-prof" type="checkbox" /><span>Deception (Cha)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="int"><input id="skill-history-prof" type="checkbox" /><span>History (Int)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="wis"><input id="skill-insight-prof" type="checkbox" /><span>Insight (Wis)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="cha"><input id="skill-intimidation-prof" type="checkbox" /><span>Intimidation (Cha)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="int"><input id="skill-investigation-prof" type="checkbox" /><span>Investigation (Int)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="wis"><input id="skill-medicine-prof" type="checkbox" /><span>Medicine (Wis)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="int"><input id="skill-nature-prof" type="checkbox" /><span>Nature (Int)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="wis"><input id="skill-perception-prof" type="checkbox" /><span>Perception (Wis)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="cha"><input id="skill-performance-prof" type="checkbox" /><span>Performance (Cha)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="cha"><input id="skill-persuasion-prof" type="checkbox" /><span>Persuasion (Cha)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="int"><input id="skill-religion-prof" type="checkbox" /><span>Religion (Int)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="dex"><input id="skill-sleight-of-hand-prof" type="checkbox" /><span>Sleight of Hand (Dex)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="dex"><input id="skill-stealth-prof" type="checkbox" /><span>Stealth (Dex)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="wis"><input id="skill-survival-prof" type="checkbox" /><span>Survival (Wis)</span><span class="skill-value list-value">+0</span></div>
              </div>
            </div>



              <div class="panel grid-equipment">
              <div class="panel-label">Equipment</div>
              <div class="actions" style="margin-bottom: 8px;">
                <button id="add-weapon" type="button">Add Weapon/Armor</button>
                <button id="attack-roll" type="button">Hit</button>
                <span class="active-weapon" id="active-weapon-label">No weapon selected</span>
                <span class="equip-status" id="equip-status"></span>
              </div>
              <div id="equipment-list"></div>
            </div>
            <div class="panel grid-spells">
              <div class="panel-label">Spells</div>
              <div class="tabs">
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-1" checked />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-2" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-3" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-4" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-5" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-6" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-7" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-8" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-9" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-10" />
                <div class="tab-buttons">
                  <label for="spell-tab-1">C</label>
                  <label for="spell-tab-2">1</label>
                  <label for="spell-tab-3">2</label>
                  <label for="spell-tab-4">3</label>
                  <label for="spell-tab-5">4</label>
                  <label for="spell-tab-6">5</label>
                  <label for="spell-tab-7">6</label>
                  <label for="spell-tab-8">7</label>
                  <label for="spell-tab-9">8</label>
                  <label for="spell-tab-10">9</label>
                </div>
                <div class="tab-panels">
                  <div class="tab-panel" id="spell-panel-1"></div>
                  <div class="tab-panel" id="spell-panel-2"></div>
                  <div class="tab-panel" id="spell-panel-3"></div>
                  <div class="tab-panel" id="spell-panel-4"></div>
                  <div class="tab-panel" id="spell-panel-5"></div>
                  <div class="tab-panel" id="spell-panel-6"></div>
                  <div class="tab-panel" id="spell-panel-7"></div>
                  <div class="tab-panel" id="spell-panel-8"></div>
                  <div class="tab-panel" id="spell-panel-9"></div>
                  <div class="tab-panel" id="spell-panel-10"></div>
                </div>
                <div class="tab-actions">
                  <button id="spell-attack-roll" type="button">Hit</button>
                  <button id="add-spell" type="button">Add Spell</button>
                  <button id="remove-spell" type="button">Remove Spell</button>
                </div>
              </div>
            </div>
            <div class="panel grid-items">
              <div class="panel-label">Items</div>
              <div class="actions" style="margin-bottom: 8px;">
                <button id="add-item" type="button">Add Item</button>
              </div>
              <div id="items-list"></div>
            </div>
            </div>

          
        </section>
      </div>
    </div>
    <aside class="sticky-roll" aria-live="polite">
      <div class="sticky-roll-title">Dice Roll</div>
      <div id="roll-result">No rolls yet.</div>
    </aside>
    <audio id="dice-sound" src="diceroll.mp3" preload="auto"></audio>
    <audio id="weapon-sound" src="weapon.mp3" preload="auto"></audio>
    <audio id="spellcast-sound" src="SpellCast.mp3" preload="auto"></audio>
    <aside class="item-panel" id="item-panel" aria-live="polite" aria-label="Item details">
      <div class="item-panel-header">
        <h2 class="item-panel-title" id="item-panel-title">Item</h2>
        <button class="item-panel-close" id="item-panel-close" type="button" aria-label="Close item details"></button>
      </div>
      <div class="item-panel-body" id="item-panel-body"></div>
    </aside>
    <aside class="weapon-picker" id="weapon-picker" aria-live="polite" aria-label="Weapon picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <input id="weapon-search" type="search" placeholder="Search weapons..." />
        <button id="weapon-picker-add" class="weapon-picker-add" type="button" disabled>Add</button>
        <button id="weapon-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="weapon-picker-list"></div>
    </aside>
    <aside class="weapon-picker race-picker" id="race-picker" aria-live="polite" aria-label="Race picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <input id="race-search" type="search" placeholder="Search races..." />
        <button id="race-picker-add" class="weapon-picker-add" type="button" disabled>Add</button>
        <button id="race-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="race-picker-list"></div>
    </aside>
    <aside class="weapon-picker size-picker" id="size-picker" aria-live="polite" aria-label="Size picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <div class="picker-title">Choose size</div>
        <button id="size-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="size-picker-list"></div>
    </aside>
    <aside class="weapon-picker alignment-picker" id="alignment-picker" aria-live="polite" aria-label="Alignment picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <div class="picker-title">Choose alignment</div>
        <button id="alignment-picker-add" class="weapon-picker-add" type="button" disabled>Add</button>
        <button id="alignment-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="alignment-picker-list"></div>
    </aside>
    <aside class="weapon-picker ability-picker" id="ability-picker" aria-live="polite" aria-label="Ability score picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <div class="picker-title">Choose ability scores</div>
        <button id="ability-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div class="ability-options" id="ability-options"></div>
      <div class="ability-values" id="ability-values"></div>
      <div class="ability-choices" id="ability-choices"></div>
    </aside>
    <aside class="weapon-picker spell-picker" id="spell-picker" aria-live="polite" aria-label="Spell picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <input id="spell-search" type="search" placeholder="Search cantrips..." />
        <button id="spell-picker-add" class="weapon-picker-add" type="button" disabled>Add</button>
        <button id="spell-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="spell-picker-list"></div>
    </aside>
    <aside class="weapon-picker feat-picker" id="feat-picker" aria-live="polite" aria-label="Feat picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <input id="feat-search" type="search" placeholder="Search feats..." />
        <button id="feat-picker-add" class="weapon-picker-add" type="button" disabled>Add</button>
        <button id="feat-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="feat-picker-list"></div>
    </aside>
    <aside class="weapon-picker feat-choice-picker" id="feat-choice-picker" aria-live="polite" aria-label="Feat choice picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <div class="picker-title">Feat choices</div>
        <button id="feat-choice-apply" class="weapon-picker-add" type="button" disabled>Apply</button>
        <button id="feat-choice-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="feat-choice-body"></div>
    </aside>
    <aside class="weapon-picker class-picker" id="class-picker" aria-live="polite" aria-label="Class picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <input id="class-search" type="search" placeholder="Search classes..." />
        <button id="class-picker-add" class="weapon-picker-add" type="button" disabled>Add</button>
        <button id="class-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="class-picker-list"></div>
    </aside>
    <aside class="weapon-picker class-equipment-picker" id="class-equipment-picker" aria-live="polite" aria-label="Class starting equipment" aria-hidden="true">
      <div class="weapon-picker-header">
        <div class="picker-title">Class starting equipment</div>
        <button id="class-equipment-apply" class="weapon-picker-add" type="button">Apply</button>
        <button id="class-equipment-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div class="class-equipment-body" id="class-equipment-body"></div>
    </aside>
    <aside class="weapon-picker background-picker" id="background-picker" aria-live="polite" aria-label="Background picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <input id="background-search" type="search" placeholder="Search backgrounds..." />
        <button id="background-picker-add" class="weapon-picker-add" type="button" disabled>Add</button>
        <button id="background-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="background-picker-list"></div>
    </aside>
    <aside class="weapon-picker background-config-picker" id="background-config-picker" aria-live="polite" aria-label="Background choices" aria-hidden="true">
      <div class="weapon-picker-header">
        <div class="picker-title">Background choices</div>
        <button id="background-config-apply" class="weapon-picker-add" type="button">Apply</button>
        <button id="background-config-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div class="background-config-body" id="background-config-body"></div>
    </aside>
    <aside class="weapon-picker item-picker" id="item-picker" aria-live="polite" aria-label="Item picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <input id="item-search" type="search" placeholder="Search items..." />
        <button id="item-picker-add" class="weapon-picker-add" type="button" disabled>Add</button>
        <button id="item-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="item-picker-list"></div>
    </aside>
    <div class="startup-modal-overlay" id="startup-modal-overlay" aria-hidden="true">
      <div class="startup-modal" role="dialog" aria-modal="true" aria-labelledby="startup-modal-title">
        <h2 class="startup-modal-title" id="startup-modal-title">Welcome to DnD interactive sheet!</h2>
        <p class="startup-modal-copy">What you want to do ? (If you make a new you lost the current one)</p>
        <div class="startup-modal-actions">
          <button id="startup-new-character" class="startup-modal-btn startup-modal-btn-primary" type="button">New Character</button>
          <button id="startup-load-character" class="startup-modal-btn" type="button">Load Character</button>
        </div>
      </div>
    </div>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";
      import {
        getFirestore,
        doc,
        setDoc,
        getDocFromServer,
        onSnapshot,
        serverTimestamp,
        collection,
        getDocs,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

      const firebaseConfig = {
        apiKey: "AIzaSyAA4Ak_mKs67_b2LIxjSQ0TabAIa5JE4rA",
        authDomain: "dnd-dice-ca4b0.firebaseapp.com",
        projectId: "dnd-dice-ca4b0",
        storageBucket: "dnd-dice-ca4b0.firebasestorage.app",
        messagingSenderId: "338841368755",
        appId: "1:338841368755:web:80065ec73a88b9e2ba58c6",
        measurementId: "G-VPGSM8BFR6",
      };

      const app = initializeApp(firebaseConfig);
      getAnalytics(app);
      const db = getFirestore(app);

      function createClientId() {
        if (window.crypto?.randomUUID) return window.crypto.randomUUID();
        return `client_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
      }

      function getOrCreateClientId() {
        const storageKey = "dnd_client_id_v1";
        try {
          const existing = localStorage.getItem(storageKey);
          if (existing) return existing;
          const next = createClientId();
          localStorage.setItem(storageKey, next);
          return next;
        } catch (error) {
          return createClientId();
        }
      }

      const clientId = getOrCreateClientId();
      const rollRef = doc(db, "dice", `d20_${clientId}`);
      const sheetRef = doc(db, "sheets", clientId);
      const stickyRollEl = document.querySelector(".sticky-roll");
      const resultEl = document.getElementById("roll-result");
      const diceSoundEl = document.getElementById("dice-sound");
      const weaponSoundEl = document.getElementById("weapon-sound");
      const spellCastSoundEl = document.getElementById("spellcast-sound");
      const rollBtn = document.getElementById("roll-btn");
      const classInput = document.getElementById("class-level");
      const raceInput = document.getElementById("race");
      const backgroundInput = document.getElementById("background");
      const subclassInput = document.getElementById("subclass");
      const speedInput = document.getElementById("speed");
      const sizeInput = document.getElementById("size");
      const armorClassEl = document.getElementById("armor-class");
      const initiativeEl = document.getElementById("initiative");
      const levelInput = document.getElementById("level");
      const levelDecreaseBtn = document.getElementById("level-decrease");
      const levelIncreaseBtn = document.getElementById("level-increase");
      const xpInput = document.getElementById("xp");
      const totalHpInput = document.getElementById("total-hp");
      const currentHpInput = document.getElementById("current-hp");
      const proficienciesListEl = document.getElementById("proficiencies");
      const abilityPicker = document.getElementById("ability-picker");
      const abilityPickerClose = document.getElementById("ability-picker-close");
      const abilityOptionsEl = document.getElementById("ability-options");
      const abilityValuesEl = document.getElementById("ability-values");
      const abilityChoicesEl = document.getElementById("ability-choices");
      const traitsListEl = document.getElementById("traits");
      const fieldEls = Array.from(
        document.querySelectorAll(
          "input[id]:not([data-nosave]), textarea[id]:not([data-nosave]), select[id]:not([data-nosave])"
        )
      );
      const abilityScores = {
        str: document.getElementById("str-score"),
        dex: document.getElementById("dex-score"),
        con: document.getElementById("con-score"),
        int: document.getElementById("int-score"),
        wis: document.getElementById("wis-score"),
        cha: document.getElementById("cha-score"),
      };
      const abilityMods = {
        str: document.getElementById("str-mod"),
        dex: document.getElementById("dex-mod"),
        con: document.getElementById("con-mod"),
        int: document.getElementById("int-mod"),
        wis: document.getElementById("wis-mod"),
        cha: document.getElementById("cha-mod"),
      };
      const proficiencyBonusEl = document.getElementById("proficiency-bonus");
      const levelEl = document.getElementById("level");
      const passivePerceptionEl = document.getElementById("passive-wisdom-perception");
      const computedDisplayEls = [levelEl, xpInput, passivePerceptionEl, speedInput, totalHpInput, armorClassEl, initiativeEl];
      const saveRows = Array.from(document.querySelectorAll(".list-item[data-ability]"))
        .filter((row) => row.querySelector(".save-value"));
      const skillRows = Array.from(document.querySelectorAll(".list-item[data-ability]"))
        .filter((row) => row.querySelector(".skill-value"));
      skillRows.forEach((row) => {
        const checkbox = row.querySelector("input[type='checkbox']");
        if (checkbox) {
          checkbox.disabled = true;
        }
      });
      const attackRollBtn = document.getElementById("attack-roll");
      const attackProfEl = document.getElementById("attack-prof");
      const addWeaponBtn = document.getElementById("add-weapon");
      const spellAttackRollBtn = document.getElementById("spell-attack-roll");
      const addSpellBtn = document.getElementById("add-spell");
      const removeSpellBtn = document.getElementById("remove-spell");
      const addItemBtn = document.getElementById("add-item");
      const activeWeaponLabel = document.getElementById("active-weapon-label");
      const equipStatusEl = document.getElementById("equip-status");
      const weaponPicker = document.getElementById("weapon-picker");
      const weaponPickerList = document.getElementById("weapon-picker-list");
      const weaponSearch = document.getElementById("weapon-search");
      const weaponPickerAdd = document.getElementById("weapon-picker-add");
      const weaponPickerClose = document.getElementById("weapon-picker-close");
      const racePicker = document.getElementById("race-picker");
      const racePickerList = document.getElementById("race-picker-list");
      const raceSearch = document.getElementById("race-search");
      const racePickerAdd = document.getElementById("race-picker-add");
      const racePickerClose = document.getElementById("race-picker-close");
      const sizePicker = document.getElementById("size-picker");
      const sizePickerList = document.getElementById("size-picker-list");
      const sizePickerClose = document.getElementById("size-picker-close");
      const alignmentPicker = document.getElementById("alignment-picker");
      const alignmentPickerList = document.getElementById("alignment-picker-list");
      const alignmentPickerAdd = document.getElementById("alignment-picker-add");
      const alignmentPickerClose = document.getElementById("alignment-picker-close");
      const alignmentPickerTitle = alignmentPicker?.querySelector(".picker-title") || null;
      const spellPicker = document.getElementById("spell-picker");
      const spellPickerList = document.getElementById("spell-picker-list");
      const spellSearch = document.getElementById("spell-search");
      const spellPickerAdd = document.getElementById("spell-picker-add");
      const spellPickerClose = document.getElementById("spell-picker-close");
      const featPicker = document.getElementById("feat-picker");
      const featPickerList = document.getElementById("feat-picker-list");
      const featSearch = document.getElementById("feat-search");
      const featPickerAdd = document.getElementById("feat-picker-add");
      const featPickerClose = document.getElementById("feat-picker-close");
      const featChoicePicker = document.getElementById("feat-choice-picker");
      const featChoiceBody = document.getElementById("feat-choice-body");
      const featChoiceApply = document.getElementById("feat-choice-apply");
      const featChoiceClose = document.getElementById("feat-choice-close");
      const spellTabInputs = Array.from(document.querySelectorAll("input[name='spells-tab']"));
      const classPicker = document.getElementById("class-picker");
      const classPickerList = document.getElementById("class-picker-list");
      const classSearch = document.getElementById("class-search");
      const classPickerAdd = document.getElementById("class-picker-add");
      const classPickerClose = document.getElementById("class-picker-close");
      const classEquipmentPicker = document.getElementById("class-equipment-picker");
      const classEquipmentBody = document.getElementById("class-equipment-body");
      const classEquipmentApply = document.getElementById("class-equipment-apply");
      const classEquipmentClose = document.getElementById("class-equipment-close");
      const backgroundPicker = document.getElementById("background-picker");
      const backgroundPickerList = document.getElementById("background-picker-list");
      const backgroundSearch = document.getElementById("background-search");
      const backgroundPickerAdd = document.getElementById("background-picker-add");
      const backgroundPickerClose = document.getElementById("background-picker-close");
      const backgroundConfigPicker = document.getElementById("background-config-picker");
      const backgroundConfigBody = document.getElementById("background-config-body");
      const backgroundConfigApply = document.getElementById("background-config-apply");
      const backgroundConfigClose = document.getElementById("background-config-close");
      const itemPicker = document.getElementById("item-picker");
      const itemPickerList = document.getElementById("item-picker-list");
      const itemSearch = document.getElementById("item-search");
      const itemPickerAdd = document.getElementById("item-picker-add");
      const itemPickerClose = document.getElementById("item-picker-close");
      const startupModalOverlay = document.getElementById("startup-modal-overlay");
      const startupNewCharacterBtn = document.getElementById("startup-new-character");
      const startupLoadCharacterBtn = document.getElementById("startup-load-character");
      const cantripPanel = document.getElementById("spell-panel-1");
      const spellLevel1Panel = document.getElementById("spell-panel-2");
      const spellLevel2Panel = document.getElementById("spell-panel-3");
      const spellLevel3Panel = document.getElementById("spell-panel-4");
      const itemPanel = document.getElementById("item-panel");
      const itemPanelTitle = document.getElementById("item-panel-title");
      const itemPanelBody = document.getElementById("item-panel-body");
      const itemPanelClose = document.getElementById("item-panel-close");
      const equipmentListEl = document.getElementById("equipment-list");
      const itemsListEl = document.getElementById("items-list");
      let equipmentItems = [];
      let inventoryItems = [];
      let cantripItems = [];
      let spellLevel1Items = [];
      let spellLevel2Items = [];
      let spellLevel3Items = [];
      let activeWeaponName = "";
      let pickerSelected = "";
      let cantripSelected = "";
      let featSelected = "";
      let itemSelected = "";
      let raceSelected = "";
      let sizeSelected = "";
      let backgroundSelected = "";
      let currentRaceTraits = [];
      let equippedMainId = "";
      let equippedOffhandId = "";
      let equippedMainTwoHanded = false;
      let equippedArmorId = "";
      let equippedShieldId = "";
      let isRemoteUpdate = false;
      let saveTimer = null;
      let rollWindowHideTimer = null;
      const ROLL_WINDOW_HIDE_MS = 10000;
      let currentRaceSpeed = "";
      let currentRaceSizes = [];
      let suppressAbilityScoreDefaults = false;
      const LOCAL_SHEET_STORAGE_KEY = "dnd_sheet_local_v1";
      const DEFAULT_ABILITY_SCORE = 10;
      const DEFAULT_LEVEL = 10;
      const DEFAULT_XP = 10;
      const FEAT_LEVEL_MILESTONES = [4, 8, 12, 16, 19];
      const FEAT_LEVEL_SET = new Set(FEAT_LEVEL_MILESTONES.map((level) => String(level)));
      let featPromptLevel = 0;
      let lastObservedLevelForFeatPrompt = DEFAULT_LEVEL;
      let lastObservedClassForProgression = "";
      let lastObservedLevelForProgression = DEFAULT_LEVEL;
      let selectedFeatItems = [];
      let featSelectionsByLevel = FEAT_LEVEL_MILESTONES.reduce((acc, level) => {
        acc[String(level)] = "";
        return acc;
      }, {});
      let featChoiceSelectionsByLevel = FEAT_LEVEL_MILESTONES.reduce((acc, level) => {
        acc[String(level)] = {};
        return acc;
      }, {});
      let appliedFeatAbilityBonuses = {
        str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0,
      };
      let pendingFeatChoiceContext = null;

      function toNumber(value) {
        const num = Number(value);
        return Number.isFinite(num) ? num : 0;
      }

      function floorRollTotal(value) {
        const num = Number(value);
        if (!Number.isFinite(num)) return 1;
        return Math.max(1, Math.floor(num));
      }

      function formatMod(num) {
        if (!Number.isFinite(num)) return "";
        return num >= 0 ? `+${num}` : `${num}`;
      }

      function setListValue(el, value) {
        if (!el) return;
        if ("value" in el) {
          el.value = value;
          return;
        }
        el.textContent = value;
      }

      function getListValue(el) {
        if (!el) return "";
        if ("value" in el) {
          return el.value;
        }
        return el.textContent || "";
      }

      function computeAbilityMod(score) {
        if (!Number.isFinite(score)) return 0;
        return Math.floor((score - 10) / 2);
      }

      function getFeatMilestoneLevel(level) {
        const key = String(level || "").trim();
        if (!FEAT_LEVEL_SET.has(key)) return 0;
        return Number(key) || 0;
      }

      function normalizeFeatSelectionMap(raw) {
        const normalized = FEAT_LEVEL_MILESTONES.reduce((acc, level) => {
          acc[String(level)] = "";
          return acc;
        }, {});
        if (!raw || typeof raw !== "object") return normalized;
        FEAT_LEVEL_MILESTONES.forEach((level) => {
          const key = String(level);
          const value = raw[key];
          if (typeof value === "string" && value.trim()) {
            normalized[key] = value.trim();
          }
        });
        return normalized;
      }

      function normalizeFeatChoiceSelectionMap(raw) {
        const normalized = FEAT_LEVEL_MILESTONES.reduce((acc, level) => {
          acc[String(level)] = {};
          return acc;
        }, {});
        if (!raw || typeof raw !== "object") return normalized;
        FEAT_LEVEL_MILESTONES.forEach((level) => {
          const key = String(level);
          const source = raw[key];
          if (!source || typeof source !== "object") return;
          const next = {};
          Object.entries(source).forEach(([choiceKey, values]) => {
            if (!Array.isArray(values)) return;
            const cleaned = values.map((entry) => String(entry || "").trim()).filter(Boolean);
            if (cleaned.length) {
              next[String(choiceKey)] = cleaned;
            }
          });
          normalized[key] = next;
        });
        return normalized;
      }

      function normalizeFeatChoiceSelections(raw) {
        const next = {};
        if (!raw || typeof raw !== "object") return next;
        Object.entries(raw).forEach(([choiceKey, values]) => {
          if (!Array.isArray(values)) return;
          const cleaned = values.map((entry) => String(entry || "").trim()).filter(Boolean);
          if (cleaned.length) {
            next[String(choiceKey)] = cleaned;
          }
        });
        return next;
      }

      function normalizeBackgroundFeatChoiceSelectionMap(raw) {
        const next = {};
        if (!raw || typeof raw !== "object") return next;
        Object.entries(raw).forEach(([featKey, selections]) => {
          const key = normalizeKey(featKey);
          if (!key) return;
          next[key] = normalizeFeatChoiceSelections(selections);
        });
        return next;
      }

      function normalizeFeatNameList(values = []) {
        if (!Array.isArray(values)) return [];
        const out = [];
        const seen = new Set();
        values.forEach((entry) => {
          const raw = String(entry || "").trim();
          if (!raw) return;
          const feat = getFeatData(raw);
          const resolved = String(feat?.name || raw).trim();
          const key = normalizeKey(resolved);
          if (!key || seen.has(key)) return;
          seen.add(key);
          out.push(resolved);
        });
        return out;
      }

      function getBackgroundFeatChoiceSelections(featName) {
        const key = normalizeKey(featName);
        if (!key) return {};
        const selections = appliedBackgroundFeatChoiceSelections[key];
        return selections && typeof selections === "object" ? selections : {};
      }

      function forEachAppliedFeatSelection(callback) {
        FEAT_LEVEL_MILESTONES.forEach((level) => {
          const levelKey = String(level);
          const featName = String(featSelectionsByLevel[levelKey] || "").trim();
          if (!featName) return;
          const choiceSelections = featChoiceSelectionsByLevel[levelKey] && typeof featChoiceSelectionsByLevel[levelKey] === "object"
            ? featChoiceSelectionsByLevel[levelKey]
            : {};
          callback(featName, choiceSelections);
        });
        normalizeFeatNameList(appliedBackgroundFeatNames).forEach((featName) => {
          callback(featName, getBackgroundFeatChoiceSelections(featName));
        });
      }

      function normalizeAbilityBonusMap(raw) {
        const out = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
        if (!raw || typeof raw !== "object") return out;
        Object.keys(out).forEach((key) => {
          out[key] = Number(raw[key]) || 0;
        });
        return out;
      }

      function rebuildSelectedFeatItems() {
        const levelFeats = FEAT_LEVEL_MILESTONES
          .map((level) => String(featSelectionsByLevel[String(level)] || "").trim())
          .filter(Boolean);
        const backgroundFeats = normalizeFeatNameList(appliedBackgroundFeatNames);
        selectedFeatItems = normalizeFeatNameList([...levelFeats, ...backgroundFeats]);
      }

      function pruneFeatSelectionsForLevel(level) {
        let changed = false;
        FEAT_LEVEL_MILESTONES.forEach((milestone) => {
          const key = String(milestone);
          if (milestone > level) {
            if (featSelectionsByLevel[key]) {
              featSelectionsByLevel[key] = "";
              changed = true;
            }
            if (featChoiceSelectionsByLevel[key] && Object.keys(featChoiceSelectionsByLevel[key]).length) {
              featChoiceSelectionsByLevel[key] = {};
              changed = true;
            }
          }
        });
        if (changed) {
          rebuildSelectedFeatItems();
          recomputeFeatAbilityBonuses();
          renderTraitsList();
          updateAllSkillProficiencies();
        }
        return changed;
      }

      function isBlankValue(value) {
        return value === undefined || value === null || String(value).trim() === "";
      }

      function applyBaseDefaults() {
        if (!suppressAbilityScoreDefaults) {
          Object.values(abilityScores).forEach((el) => {
            if (!el) return;
            if (isBlankValue(getListValue(el))) {
              setListValue(el, String(DEFAULT_ABILITY_SCORE));
            }
          });
        }
        if (levelEl && isBlankValue(getListValue(levelEl))) {
          setListValue(levelEl, String(DEFAULT_LEVEL));
        }
        if (xpInput && isBlankValue(getListValue(xpInput))) {
          setListValue(xpInput, String(DEFAULT_XP));
        }
      }

      function getFieldValue(el) {
        if (el.type === "checkbox") {
          return el.checked;
        }
        return el.value;
      }

      function applyFieldValue(el, value) {
        if (value === undefined) return;
        if (el.type === "checkbox") {
          el.checked = Boolean(value);
          return;
        }
        el.value = value;
      }

      const proficiencyByLevel = [
        2, 2, 2, 2,
        3, 3, 3, 3,
        4, 4, 4, 4,
        5, 5, 5, 5,
        6, 6, 6, 6,
      ];

      function recalcDerived() {
        const levelRaw = toNumber(getListValue(levelEl));
        const level = Math.min(Math.max(levelRaw || DEFAULT_LEVEL, 1), 20);
        const levelChanged = level !== lastObservedLevelForFeatPrompt;
        lastObservedLevelForFeatPrompt = level;
        const profBonus = proficiencyByLevel[level - 1] ?? 2;
        if (proficiencyBonusEl) {
          proficiencyBonusEl.value = formatMod(profBonus);
        }
        const mods = {};
        Object.entries(abilityScores).forEach(([ability, scoreEl]) => {
          const score = toNumber(getListValue(scoreEl));
          const mod = computeAbilityMod(score);
          mods[ability] = mod;
          if (abilityMods[ability]) {
            setListValue(abilityMods[ability], formatMod(mod));
          }
        });

        saveRows.forEach((row) => {
          const ability = row.dataset.ability;
          const checkbox = row.querySelector("input[type='checkbox']");
          const valueEl = row.querySelector(".save-value");
          const base = mods[ability] ?? 0;
          const total = base + (checkbox?.checked ? profBonus : 0);
          setListValue(valueEl, formatMod(total));
        });

        skillRows.forEach((row) => {
          const ability = row.dataset.ability;
          const checkbox = row.querySelector("input[type='checkbox']");
          const valueEl = row.querySelector(".skill-value");
          const base = mods[ability] ?? 0;
          const total = base + (checkbox?.checked ? profBonus : 0);
          setListValue(valueEl, formatMod(total));
        });

        updateArmorClass(mods);
        if (initiativeEl) {
          setListValue(initiativeEl, formatMod(mods.dex ?? 0));
        }
        if (classesLoaded && classInput?.value) {
          const classEntry = classByName.get(classInput.value);
          if (classEntry) {
            updateTotalHpForClass(classEntry, mods);
          }
        }
        syncClassLevelProgressionForCurrentCharacter();

        if (passivePerceptionEl) {
          const perceptionRow = skillRows.find(
            (row) => row.textContent && row.textContent.includes("Perception")
          );
          const perceptionValueEl = perceptionRow?.querySelector(".skill-value");
          const perceptionMod = toNumber(getListValue(perceptionValueEl));
          setListValue(passivePerceptionEl, String(10 + perceptionMod));
        }

        if (!isRemoteUpdate) {
          if (levelChanged) {
            if (featPromptLevel > level) {
              featPromptLevel = 0;
              setFeatPickerOpen(false);
              setFeatChoicePickerOpen(false);
            }
            const changedByPrune = pruneFeatSelectionsForLevel(level);
            if (changedByPrune) {
              buildCantripPickerList(spellSearch?.value || "");
              recalcDerived();
              return;
            }
            maybePromptFeatForLevel(level);
          }
          scheduleSave();
        }
      }

      function updateArmorClass(mods = {}) {
        const dex = mods.dex ?? computeAbilityMod(toNumber(getListValue(abilityScores.dex)));
        const con = mods.con ?? computeAbilityMod(toNumber(getListValue(abilityScores.con)));
        const wis = mods.wis ?? computeAbilityMod(toNumber(getListValue(abilityScores.wis)));
        const className = String(classInput?.value || "").toLowerCase();
        const equippedArmor = getEquippedArmorById(equippedArmorId)?.armor || null;
        const equippedShield = getEquippedArmorById(equippedShieldId)?.armor || null;

        let acBase = 10 + dex;
        if (equippedArmor) {
          const dexAllowed = equippedArmor.dexBonus?.allowed !== false;
          const dexMax = equippedArmor.dexBonus?.max;
          const dexBonus = dexAllowed
            ? (Number.isFinite(Number(dexMax)) ? Math.min(dex, Number(dexMax)) : dex)
            : 0;
          acBase = (Number(equippedArmor.baseAC) || 10) + dexBonus;
        } else if (className.includes("barbarian")) {
          acBase = 10 + dex + con;
        } else if (className.includes("monk")) {
          acBase = 10 + dex + wis;
        }
        const shieldBonus = equippedShield ? (Number(equippedShield.baseAC) || 2) : 0;
        setListValue(armorClassEl, String(acBase + shieldBonus));
      }

      function adjustLevel(delta) {
        const current = toNumber(getListValue(levelEl)) || 1;
        const next = Math.min(20, Math.max(1, current + delta));
        if (next === current) return;
        setListValue(levelEl, String(next));
        recalcDerived();
      }

      let weaponTable = [];
      let weaponByName = new Map();
      let weaponList = [];
      let weaponsLoaded = false;
      let armorTable = [];
      let armorByName = new Map();
      let armorByKey = new Map();
      let armorsLoaded = false;
      let cantripTable = [];
      let cantripByName = new Map();
      let cantripList = [];
      let cantripsLoaded = false;
      let spellLevel1Table = [];
      let spellLevel1ByName = new Map();
      let spellLevel1Loaded = false;
      let spellLevel2Table = [];
      let spellLevel2ByName = new Map();
      let spellLevel2Loaded = false;
      let spellLevel3Table = [];
      let spellLevel3ByName = new Map();
      let spellLevel3Loaded = false;
      let itemTable = [];
      let itemByName = new Map();
      let itemsLoaded = false;
      let traitByName = new Map();
      let traitsLoaded = false;
      let featTable = [];
      let featByName = new Map();
      let featList = [];
      let featsLoaded = false;
      let raceTable = [];
      let raceByName = new Map();
      let raceList = [];
      let racesLoaded = false;
      let backgroundTable = [];
      let backgroundByName = new Map();
      let backgroundList = [];
      let backgroundsLoaded = false;
      let classTable = [];
      let classByName = new Map();
      let classList = [];
      let classesLoaded = false;
      let classLevelUpTable = {};
      let classLevelUpByName = new Map();
      let classLevelUpLoaded = false;
      let currentClassProgressionFeatures = [];
      let classSelected = "";
      let pendingBackgroundEntry = null;
      let pendingBackgroundAbilityMode = 0;
      let pendingBackgroundAbilityAssignments = [];
      let pendingBackgroundEquipmentChoice = "A";
      let appliedBackgroundName = "";
      let appliedBackgroundAbilityBonuses = {
        str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0,
      };
      let appliedBackgroundSkillIds = [];
      let appliedBackgroundInventoryNames = [];
      let appliedBackgroundEquipmentIds = [];
      let appliedBackgroundFeatNames = [];
      let appliedBackgroundFeatChoiceSelections = {};
      let pendingClassEquipmentEntry = null;
      let pendingClassEquipmentSelections = [];
      let appliedClassEquipmentName = "";
      let appliedClassInventoryNames = [];
      let appliedClassEquipmentIds = [];
      let currentWeaponProficiencies = [];

      function refreshWeaponIndex() {
        weaponByName = new Map(weaponTable.map((weapon) => [weapon.name, weapon]));
        weaponList = weaponTable.map((weapon) => weapon.name);
      }

      function refreshArmorIndex() {
        armorByName = new Map(armorTable.map((armor) => [armor.name, armor]));
        armorByKey = new Map(armorTable.map((armor) => [normalizeKey(armor.name), armor]));
      }

      function refreshCantripIndex() {
        cantripByName = new Map(cantripTable.map((spell) => [spell.name, spell]));
        cantripList = cantripTable.map((spell) => spell.name);
      }

      function refreshSpellLevel1Index() {
        spellLevel1ByName = new Map(spellLevel1Table.map((spell) => [spell.name, spell]));
      }

      function refreshSpellLevel2Index() {
        spellLevel2ByName = new Map(spellLevel2Table.map((spell) => [spell.name, spell]));
      }

      function refreshSpellLevel3Index() {
        spellLevel3ByName = new Map(spellLevel3Table.map((spell) => [spell.name, spell]));
      }

      function refreshClassIndex() {
        classByName = new Map(classTable.map((entry) => [entry.name, entry]));
        classList = classTable.map((entry) => entry.name);
      }

      function refreshClassLevelUpIndex() {
        classLevelUpByName = new Map();
        Object.entries(classLevelUpTable || {}).forEach(([name, entry]) => {
          const key = String(name || "").trim();
          if (!key || !entry || typeof entry !== "object") return;
          classLevelUpByName.set(key, entry);
          classLevelUpByName.set(normalizeKey(key), entry);
        });
      }

      function refreshBackgroundIndex() {
        backgroundByName = new Map(backgroundTable.map((entry) => [entry.name, entry]));
        backgroundList = backgroundTable.map((entry) => entry.name);
      }

      function normalizeRaceSizes(value) {
        if (Array.isArray(value)) {
          return value.map((entry) => String(entry || "").trim()).filter(Boolean);
        }
        if (value === null || value === undefined) return [];
        const text = String(value).trim();
        return text ? [text] : [];
      }

      function normalizeRaceSpeed(value) {
        const num = Number(value);
        return Number.isFinite(num) ? num : "";
      }

      function normalizeGoldValue(value) {
        const text = String(value ?? "").trim();
        if (!text) return "";
        const num = Number(text.replace(/[^0-9.-]/g, ""));
        return Number.isFinite(num) ? num : text;
      }

      function formatGoldValue(value) {
        if (typeof value === "number" && Number.isFinite(value)) {
          return `${value} gp`;
        }
        const text = String(value ?? "").trim();
        return text || "--";
      }

      function normalizeKey(value) {
        return String(value || "")
          .trim()
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, " ")
          .trim();
      }

      function firstNonBlank(values = []) {
        for (const value of values) {
          if (value === undefined || value === null) continue;
          const text = Array.isArray(value) ? value.join(" ").trim() : String(value).trim();
          if (text) return text;
        }
        return "";
      }

      async function fetchJsonWithFallback(paths = [], label = "JSON") {
        let lastStatus = "unavailable";
        for (const path of paths) {
          try {
            const response = await fetch(path);
            if (!response.ok) {
              lastStatus = String(response.status);
              continue;
            }
            return await response.json();
          } catch (error) {
            lastStatus = error?.message || "fetch failed";
          }
        }
        throw new Error(`${label} fetch failed: ${lastStatus}`);
      }

      function normalizeTagList(values) {
        if (!Array.isArray(values)) return [];
        return values
          .map((value) => String(value || "").trim().toLowerCase())
          .filter(Boolean);
      }

      function normalizeSingleTag(value) {
        return String(value || "").trim().toLowerCase();
      }

      function getSelectedTagSetFromInputs(ids = []) {
        const tags = new Set();
        ids.forEach((id) => {
          const input = document.getElementById(id);
          if (!input || !("value" in input)) return;
          String(input.value || "")
            .split(/[,\n;|/]+/)
            .map((entry) => entry.trim().toLowerCase())
            .filter(Boolean)
            .forEach((entry) => tags.add(entry));
        });
        return tags;
      }

      function raceTagMatches(cantripSpecies, selectedRace) {
        if (!selectedRace) return false;
        const race = selectedRace.toLowerCase();
        return cantripSpecies.some((entry) =>
          entry === race || entry.startsWith(`${race} (`) || entry.includes(race)
        );
      }

      function subclassTagMatches(cantripSubclasses, selectedClass, selectedSubclasses) {
        if (!cantripSubclasses.length || !selectedSubclasses.size) return false;
        const classKey = selectedClass.toLowerCase();
        return cantripSubclasses.some((entry) => {
          const [entryClassRaw, entrySubclassRaw] = entry.split(":");
          const entryClass = String(entryClassRaw || "").trim().toLowerCase();
          const entrySubclass = String(entrySubclassRaw || "").trim().toLowerCase();
          if (!entryClass) return false;
          if (entryClass && classKey && entryClass !== classKey) return false;
          return (
            selectedSubclasses.has(entrySubclass) ||
            selectedSubclasses.has(`${entryClass}: ${entrySubclass}`.trim())
          );
        });
      }

      function featTagMatches(cantripFeats, selectedFeats) {
        if (!cantripFeats.length || !selectedFeats.size) return false;
        return cantripFeats.some((entry) => selectedFeats.has(entry));
      }

      function backgroundTagMatches(cantripBackgrounds, selectedBackground) {
        if (!cantripBackgrounds.length || !selectedBackground) return false;
        return cantripBackgrounds.some((entry) => entry === selectedBackground);
      }

      function getSelectedSubclassTags() {
        const tags = getSelectedTagSetFromInputs(["subclass", "class-subclass", "subclass-level"]);
        const raceSubclass = String(selectedRaceSubclass || "").trim().toLowerCase();
        if (raceSubclass) {
          tags.add(raceSubclass);
          const raceName = String(raceInput?.value || "").trim().toLowerCase();
          if (raceName) {
            tags.add(`${raceName}: ${raceSubclass}`);
          }
        }
        return tags;
      }

      function getSelectedFeatTags() {
        const tags = getSelectedTagSetFromInputs(["feats", "feat", "character-feats"]);
        selectedFeatItems
          .map((entry) => normalizeSingleTag(entry))
          .filter(Boolean)
          .forEach((entry) => tags.add(entry));
        return tags;
      }

      function cantripAllowedForCharacter(spell) {
        const selectedClass = String(classInput?.value || "").trim().toLowerCase();
        const selectedRace = String(raceInput?.value || "").trim().toLowerCase();
        const selectedBackground = normalizeSingleTag(backgroundInput?.value || "");
        const selectedSubclasses = getSelectedSubclassTags();
        const selectedFeats = getSelectedFeatTags();

        const cantripClasses = normalizeTagList(spell.classes);
        const cantripSubclasses = normalizeTagList(spell.subclasses);
        const cantripSpecies = normalizeTagList(spell.species);
        const cantripFeats = normalizeTagList(spell.feats);
        const cantripBackgrounds = normalizeTagList(spell.backgrounds);

        const hasRestrictions =
          cantripClasses.length ||
          cantripSubclasses.length ||
          cantripSpecies.length ||
          cantripFeats.length ||
          cantripBackgrounds.length;
        if (!hasRestrictions) return true;
        if (!selectedClass && !selectedRace && !selectedBackground && !selectedSubclasses.size && !selectedFeats.size) {
          return true;
        }

        if (selectedClass && cantripClasses.includes(selectedClass)) return true;
        if (selectedClass && subclassTagMatches(cantripSubclasses, selectedClass, selectedSubclasses)) return true;
        if (selectedRace && raceTagMatches(cantripSpecies, selectedRace)) return true;
        if (featTagMatches(cantripFeats, selectedFeats)) return true;
        if (backgroundTagMatches(cantripBackgrounds, selectedBackground)) return true;

        return false;
      }

      function refreshRaceIndex() {
        raceByName = new Map(raceTable.map((race) => [race.name, race]));
        raceList = raceTable.map((race) => race.name);
      }

      function refreshItemIndex() {
        itemByName = new Map();
        itemTable.forEach((item) => {
          itemByName.set(item.name, item);
          itemByName.set(normalizeKey(item.name), item);
        });
      }

      async function loadWeapons() {
        try {
          const snapshot = await getDocs(collection(db, "weapons"));
          weaponTable = snapshot.docs
            .map((docSnap) => {
              const data = docSnap.data() || {};
              const name = (data.name || docSnap.id || "").trim();
              if (!name) return null;
              return {
                name,
                category: (data.category || "").trim(),
                damage: (data.damage || "").trim(),
                properties: (data.properties || "???").trim(),
                mastery: (data.mastery || "???").trim(),
                weight: (data.weight || "???").trim(),
                cost: (data.cost || "???").trim(),
              };
            })
            .filter(Boolean);
          refreshWeaponIndex();
          weaponsLoaded = true;
          window.weaponTable = weaponTable;
          window.weaponByName = weaponByName;
        } catch (error) {
          console.error("Failed to load weapons", error);
          weaponsLoaded = true;
        }
      }

      async function loadArmors() {
        try {
          const data = await fetchJsonWithFallback(
            ["./Data/armors.json", "./Data/Items/armors.json", "./Items/armors.json"],
            "Armor"
          );
          armorTable = Object.values(data || {})
            .map((entry) => {
              const name = (entry?.name || "").trim();
              if (!name) return null;
              return {
                name,
                type: (entry.type || "").trim(),
                baseAC: Number(entry.baseAC) || 0,
                dexBonus: entry.dexBonus || { allowed: true, max: null },
                strengthRequirement: entry.strengthRequirement ?? null,
                stealthDisadvantage: Boolean(entry.stealthDisadvantage),
                weightLb: entry.weightLb ?? null,
                costGp: entry.costGp ?? null,
                donTimeMinutes: entry.donTimeMinutes ?? null,
                doffTimeMinutes: entry.doffTimeMinutes ?? null,
                isShield: Boolean(entry.isShield),
              };
            })
            .filter(Boolean);
          refreshArmorIndex();
          armorsLoaded = true;
        } catch (error) {
          console.error("Failed to load armors", error);
          armorsLoaded = true;
        }
      }

      async function loadCantrips() {
        try {
          let loadedFromFirestore = false;
          try {
            const snapshot = await getDocs(collection(db, "cantrips"));
            if (snapshot?.docs?.length) {
              cantripTable = snapshot.docs
                .map((docSnap) => {
                  const entry = docSnap.data() || {};
                  const fallbackName = String(docSnap.id || "").trim();
                  const name = String(entry.name || fallbackName || "").trim();
                  if (!name) return null;
                  return {
                    name,
                    school: (entry.school || "").trim(),
                    level: (entry.level || "").trim(),
                    range: (entry.range || "").trim(),
                    components: (entry.components || "").trim(),
                    duration: (entry.duration || "").trim(),
                    description: (entry.description || "").trim(),
                    damageDie: String(entry["dice"] || "").trim(),
                    damageDiceCount: Number(entry["amount of dices"]) || 0,
                    cantripUpgradeDice5: String(entry["cantrip upgrade dice 5"] || "").trim(),
                    cantripUpgradeDice11: String(entry["cantrip upgrade dice 11"] || "").trim(),
                    cantripUpgradeDice17: String(entry["cantrip upgrade dice 17"] || "").trim(),
                    damageType: String(entry["damage type"] || "").trim(),
                    savingThrows: Array.isArray(entry["savingthrow"])
                      ? entry["savingthrow"].slice()
                      : Array.isArray(entry["saving throw"])
                        ? entry["saving throw"].slice()
                        : [],
                    classes: Array.isArray(entry.classes) ? entry.classes.slice() : [],
                    subclasses: Array.isArray(entry.subclasses) ? entry.subclasses.slice() : [],
                    species: Array.isArray(entry.species) ? entry.species.slice() : [],
                    feats: Array.isArray(entry.feats) ? entry.feats.slice() : [],
                    backgrounds: Array.isArray(entry.backgrounds) ? entry.backgrounds.slice() : [],
                  };
                })
                .filter(Boolean);
              loadedFromFirestore = true;
            }
          } catch (firestoreError) {
            console.warn("Cantrips Firestore load failed, falling back to JSON", firestoreError);
          }

          if (!loadedFromFirestore) {
            const data = await fetchJsonWithFallback(
              ["./Data/cantrips.json", "./Spells/Cantrip/cantrips.json"],
              "Cantrip"
            );
            cantripTable = Object.values(data || {})
              .map((entry) => {
                const name = (entry?.name || "").trim();
                if (!name) return null;
                return {
                  name,
                  school: (entry.school || "").trim(),
                  level: (entry.level || "").trim(),
                  range: (entry.range || "").trim(),
                  components: (entry.components || "").trim(),
                  duration: (entry.duration || "").trim(),
                  description: (entry.description || "").trim(),
                  damageDie: String(entry["dice"] || "").trim(),
                  damageDiceCount: Number(entry["amount of dices"]) || 0,
                  cantripUpgradeDice5: String(entry["cantrip upgrade dice 5"] || "").trim(),
                  cantripUpgradeDice11: String(entry["cantrip upgrade dice 11"] || "").trim(),
                  cantripUpgradeDice17: String(entry["cantrip upgrade dice 17"] || "").trim(),
                  damageType: String(entry["damage type"] || "").trim(),
                  savingThrows: Array.isArray(entry["savingthrow"])
                    ? entry["savingthrow"].slice()
                    : Array.isArray(entry["saving throw"])
                      ? entry["saving throw"].slice()
                      : [],
                  classes: Array.isArray(entry.classes) ? entry.classes.slice() : [],
                  subclasses: Array.isArray(entry.subclasses) ? entry.subclasses.slice() : [],
                  species: Array.isArray(entry.species) ? entry.species.slice() : [],
                  feats: Array.isArray(entry.feats) ? entry.feats.slice() : [],
                  backgrounds: Array.isArray(entry.backgrounds) ? entry.backgrounds.slice() : [],
                };
              })
              .filter(Boolean);
          }

          cantripTable = cantripTable
            .map((entry) => {
              const name = (entry?.name || "").trim();
              if (!name) return null;
              return {
                name,
                school: (entry.school || "").trim(),
                level: (entry.level || "").trim(),
                range: (entry.range || "").trim(),
                components: (entry.components || "").trim(),
                duration: (entry.duration || "").trim(),
                description: (entry.description || "").trim(),
                damageDie: String(entry["dice"] || "").trim(),
                damageDiceCount: Number(entry["amount of dices"]) || 0,
                cantripUpgradeDice5: String(entry["cantrip upgrade dice 5"] || "").trim(),
                cantripUpgradeDice11: String(entry["cantrip upgrade dice 11"] || "").trim(),
                cantripUpgradeDice17: String(entry["cantrip upgrade dice 17"] || "").trim(),
                damageType: String(entry["damage type"] || "").trim(),
                savingThrows: Array.isArray(entry["savingthrow"])
                  ? entry["savingthrow"].slice()
                  : Array.isArray(entry["saving throw"])
                    ? entry["saving throw"].slice()
                    : [],
                classes: Array.isArray(entry.classes) ? entry.classes.slice() : [],
                subclasses: Array.isArray(entry.subclasses) ? entry.subclasses.slice() : [],
                species: Array.isArray(entry.species) ? entry.species.slice() : [],
                feats: Array.isArray(entry.feats) ? entry.feats.slice() : [],
                backgrounds: Array.isArray(entry.backgrounds) ? entry.backgrounds.slice() : [],
              };
            })
            .filter(Boolean);
          refreshCantripIndex();
          cantripsLoaded = true;
          renderCantrips();
        } catch (error) {
          console.error("Failed to load cantrips", error);
          cantripsLoaded = true;
        }
      }

      function normalizeSpellLevelValue(value, fallback = 0) {
        if (typeof value === "number" && Number.isFinite(value)) return value;
        const text = String(value || "").trim().toLowerCase();
        if (!text) return fallback;
        if (text === "cantrip") return 0;
        const match = text.match(/(\d+)/);
        if (match) return Number(match[1]);
        return fallback;
      }

      async function loadSpellLevel1FromFirestore() {
        try {
          const snapshot = await getDocs(collection(db, "spell-lvl-1"));
          spellLevel1Table = snapshot.docs
            .map((docSnap) => {
              const entry = docSnap.data() || {};
              const fallbackName = String(docSnap.id || "").trim();
              const name = String(entry.name || fallbackName || "").trim();
              if (!name) return null;
              const levelValue = normalizeSpellLevelValue(entry.level, 1);
              return {
                name,
                school: String(entry.school || "").trim(),
                level: String(entry.level || `Level ${levelValue}`).trim(),
                range: String(entry.range || "").trim(),
                components: String(entry.components || "").trim(),
                duration: String(entry.duration || "").trim(),
                description: String(entry.description || "").trim(),
                damageDie: String(entry["dice"] || "").trim(),
                damageDiceCount: Number(entry["amount of dices"]) || 0,
                cantripUpgradeDice5: String(entry["cantrip upgrade dice 5"] || "").trim(),
                cantripUpgradeDice11: String(entry["cantrip upgrade dice 11"] || "").trim(),
                cantripUpgradeDice17: String(entry["cantrip upgrade dice 17"] || "").trim(),
                damageType: String(entry["damage type"] || "").trim(),
                savingThrows: Array.isArray(entry["savingthrow"])
                  ? entry["savingthrow"].slice()
                  : Array.isArray(entry["saving throw"])
                    ? entry["saving throw"].slice()
                    : [],
                classes: Array.isArray(entry.classes) ? entry.classes.slice() : [],
                subclasses: Array.isArray(entry.subclasses) ? entry.subclasses.slice() : [],
                species: Array.isArray(entry.species) ? entry.species.slice() : [],
                feats: Array.isArray(entry.feats) ? entry.feats.slice() : [],
                backgrounds: Array.isArray(entry.backgrounds) ? entry.backgrounds.slice() : [],
              };
            })
            .filter(Boolean);
          refreshSpellLevel1Index();
          spellLevel1Loaded = true;
          renderSpellLevel1();
        } catch (error) {
          console.error("Failed to load spell-lvl-1", error);
          spellLevel1Loaded = true;
        }
      }

      async function loadSpellLevel2FromFirestore() {
        try {
          const snapshot = await getDocs(collection(db, "spell-lvl-2"));
          spellLevel2Table = snapshot.docs
            .map((docSnap) => {
              const entry = docSnap.data() || {};
              const fallbackName = String(docSnap.id || "").trim();
              const name = String(entry.name || fallbackName || "").trim();
              if (!name) return null;
              const levelValue = normalizeSpellLevelValue(entry.level, 2);
              return {
                name,
                school: String(entry.school || "").trim(),
                level: String(entry.level || `Level ${levelValue}`).trim(),
                range: String(entry.range || "").trim(),
                components: String(entry.components || "").trim(),
                duration: String(entry.duration || "").trim(),
                description: String(entry.description || "").trim(),
                damageDie: String(entry["dice"] || "").trim(),
                damageDiceCount: Number(entry["amount of dices"]) || 0,
                cantripUpgradeDice5: String(entry["cantrip upgrade dice 5"] || "").trim(),
                cantripUpgradeDice11: String(entry["cantrip upgrade dice 11"] || "").trim(),
                cantripUpgradeDice17: String(entry["cantrip upgrade dice 17"] || "").trim(),
                damageType: String(entry["damage type"] || "").trim(),
                savingThrows: Array.isArray(entry["savingthrow"])
                  ? entry["savingthrow"].slice()
                  : Array.isArray(entry["saving throw"])
                    ? entry["saving throw"].slice()
                    : [],
                classes: Array.isArray(entry.classes) ? entry.classes.slice() : [],
                subclasses: Array.isArray(entry.subclasses) ? entry.subclasses.slice() : [],
                species: Array.isArray(entry.species) ? entry.species.slice() : [],
                feats: Array.isArray(entry.feats) ? entry.feats.slice() : [],
                backgrounds: Array.isArray(entry.backgrounds) ? entry.backgrounds.slice() : [],
              };
            })
            .filter(Boolean);
          refreshSpellLevel2Index();
          spellLevel2Loaded = true;
          renderSpellLevel2();
        } catch (error) {
          console.error("Failed to load spell-lvl-2", error);
          spellLevel2Loaded = true;
        }
      }

      async function loadSpellLevel3FromFirestore() {
        try {
          const snapshot = await getDocs(collection(db, "spell-lvl-3"));
          spellLevel3Table = snapshot.docs
            .map((docSnap) => {
              const entry = docSnap.data() || {};
              const fallbackName = String(docSnap.id || "").trim();
              const name = String(entry.name || fallbackName || "").trim();
              if (!name) return null;
              const levelValue = normalizeSpellLevelValue(entry.level, 3);
              return {
                name,
                school: String(entry.school || "").trim(),
                level: String(entry.level || `Level ${levelValue}`).trim(),
                range: String(entry.range || "").trim(),
                components: String(entry.components || "").trim(),
                duration: String(entry.duration || "").trim(),
                description: String(entry.description || "").trim(),
                damageDie: String(entry["dice"] || "").trim(),
                damageDiceCount: Number(entry["amount of dices"]) || 0,
                cantripUpgradeDice5: String(entry["cantrip upgrade dice 5"] || "").trim(),
                cantripUpgradeDice11: String(entry["cantrip upgrade dice 11"] || "").trim(),
                cantripUpgradeDice17: String(entry["cantrip upgrade dice 17"] || "").trim(),
                damageType: String(entry["damage type"] || "").trim(),
                savingThrows: Array.isArray(entry["savingthrow"])
                  ? entry["savingthrow"].slice()
                  : Array.isArray(entry["saving throw"])
                    ? entry["saving throw"].slice()
                    : [],
                classes: Array.isArray(entry.classes) ? entry.classes.slice() : [],
                subclasses: Array.isArray(entry.subclasses) ? entry.subclasses.slice() : [],
                species: Array.isArray(entry.species) ? entry.species.slice() : [],
                feats: Array.isArray(entry.feats) ? entry.feats.slice() : [],
                backgrounds: Array.isArray(entry.backgrounds) ? entry.backgrounds.slice() : [],
              };
            })
            .filter(Boolean);
          refreshSpellLevel3Index();
          spellLevel3Loaded = true;
          renderSpellLevel3();
        } catch (error) {
          console.error("Failed to load spell-lvl-3", error);
          spellLevel3Loaded = true;
        }
      }

      async function loadClasses() {
        try {
          let snapshot = await getDocs(collection(db, "classes"));
          if (!snapshot?.docs?.length) {
            snapshot = await getDocs(collection(db, "class"));
          }
          classTable = snapshot.docs
            .map((docSnap) => {
              const entry = docSnap.data() || {};
              const name = String(entry.name || docSnap.id || "").trim();
              if (!name) return null;
              return {
                name,
                description: String(entry.description || "").trim(),
                subclasses: Array.isArray(entry.subclasses) ? entry.subclasses.slice() : [],
                primaryAbility: Array.isArray(entry["primary ability"])
                  ? entry["primary ability"].slice()
                  : Array.isArray(entry.primaryAbility)
                    ? entry.primaryAbility.slice()
                  : [],
                hitPointDie: String(entry["hit point die"] || entry.hitPointDie || "").trim(),
                hitPointDieModifier: String(entry["hit point die modifier"] || entry.hitPointDieModifier || "").trim(),
                hitPointPerAdditionalLevelDie: String(entry["hit point per additional level die"] || entry.hitPointPerAdditionalLevelDie || "").trim(),
                savingThrows: Array.isArray(entry["saving throws proficiencies options"])
                  ? entry["saving throws proficiencies options"].slice()
                  : Array.isArray(entry.savingThrows)
                    ? entry.savingThrows.slice()
                  : [],
                weaponProficiencies: Array.isArray(entry["weapon proficiencies"])
                  ? entry["weapon proficiencies"].slice()
                  : Array.isArray(entry.weaponProficiencies)
                    ? entry.weaponProficiencies.slice()
                  : [],
                armorTraining: Array.isArray(entry["armor training"])
                  ? entry["armor training"].slice()
                  : Array.isArray(entry.armorTraining)
                    ? entry.armorTraining.slice()
                  : [],
                startingEquipment: Array.isArray(entry["starting equipment"])
                  ? entry["starting equipment"].slice()
                  : Array.isArray(entry.startingEquipment)
                    ? entry.startingEquipment.slice()
                  : [],
              };
            })
            .filter(Boolean);
          refreshClassIndex();
          classesLoaded = true;
        } catch (error) {
          console.error("Failed to load classes", error);
          classesLoaded = true;
        }
      }

      async function loadClassLevelUpData() {
        try {
          let loadedFromFirestore = false;
          const candidateCollections = [
            "class-level-up-datastore",
            "class-level-up",
            "class-level-progression",
            "class-levels",
          ];
          for (const collectionName of candidateCollections) {
            try {
              const snapshot = await getDocs(collection(db, collectionName));
              if (!snapshot?.docs?.length) continue;
              const table = {};
              snapshot.docs.forEach((docSnap) => {
                const entry = docSnap.data() || {};
                const name = String(entry.name || docSnap.id || "").trim();
                if (!name) return;
                table[name] = entry;
              });
              if (Object.keys(table).length) {
                classLevelUpTable = table;
                loadedFromFirestore = true;
                break;
              }
            } catch (firestoreError) {
              console.warn(`Class level-up Firestore load failed for ${collectionName}`, firestoreError);
            }
          }

          if (!loadedFromFirestore) {
            const data = await fetchJsonWithFallback(
              ["./Data/races/race-level-up-datastore.json"],
              "Class level-up datastore"
            );
            classLevelUpTable = data && typeof data === "object" ? data : {};
          }

          refreshClassLevelUpIndex();
          classLevelUpLoaded = true;
        } catch (error) {
          console.error("Failed to load class level-up datastore", error);
          classLevelUpTable = {};
          refreshClassLevelUpIndex();
          classLevelUpLoaded = true;
        }
      }

      async function loadItems() {
        try {
          const snapshot = await getDocs(collection(db, "items"));
          itemTable = snapshot.docs
            .map((docSnap) => {
              const data = docSnap.data() || {};
              const name = firstNonBlank([data.name, data.item, data.title, docSnap.id]);
              if (!name) return null;
              const description = firstNonBlank([data.text, data.Text]);
              const goldValue = normalizeGoldValue(firstNonBlank([data.value, data.Value]));
              return { name, description, goldValue };
            })
            .filter(Boolean);
          refreshItemIndex();
          itemsLoaded = true;
        } catch (error) {
          console.error("Failed to load items", error);
          itemsLoaded = true;
        }
      }

      async function loadRaces() {
        try {
          const snapshot = await getDocs(collection(db, "races"));
          raceTable = snapshot.docs
            .map((docSnap) => {
              const data = docSnap.data() || {};
              const name = (data.name || docSnap.id || "").trim();
              if (!name) return null;
              return {
                name,
                speed: data.speed,
                size: normalizeRaceSizes(data.size),
                creatureType: Array.isArray(data.creatureType) ? data.creatureType.slice() : [],
                traits: Array.isArray(data.traits) ? data.traits.slice() : [],
                description: (data.description || "").trim(),
                subclass: Array.isArray(data.subclass) ? data.subclass.slice() : [],
              };
            })
            .filter(Boolean);
          refreshRaceIndex();
          racesLoaded = true;
        } catch (error) {
          console.error("Failed to load races", error);
          racesLoaded = true;
        }
      }

      async function loadBackgrounds() {
        try {
          const snapshot = await getDocs(collection(db, "backgrounds"));
          backgroundTable = snapshot.docs
            .map((docSnap) => {
              const data = docSnap.data() || {};
              const name = (data.name || docSnap.id || "").trim();
              if (!name) return null;
              return {
                name,
                ability: Array.isArray(data.ability) ? data.ability.slice() : [],
                feats: Array.isArray(data.feats) ? data.feats.slice() : [],
                skillProficiencies: Array.isArray(data.skillProficiencies)
                  ? data.skillProficiencies.slice()
                  : [],
                toolProficiencies: Array.isArray(data.toolProficiencies)
                  ? data.toolProficiencies.slice()
                  : [],
                startingEquipment: Array.isArray(data.startingEquipment)
                  ? data.startingEquipment.slice()
                  : [],
              };
            })
            .filter(Boolean);
          refreshBackgroundIndex();
          backgroundsLoaded = true;
        } catch (error) {
          console.error("Failed to load backgrounds", error);
          backgroundsLoaded = true;
        }
      }

      const weaponAliases = {
        "Crossbow, Light": "Light Crossbow",
        "Crossbow, Hand": "Hand Crossbow",
        "Crossbow, Heavy": "Heavy Crossbow",
      };
      const masteryDescriptions = {
        Cleave: "On a melee hit, you can make an extra attack vs a second creature within 5 ft and reach. No ability mod to that damage unless negative. Once per turn.",
        Graze: "On a miss, deal damage equal to the ability modifier used. Same damage type.",
        Nick: "The extra Light-weapon attack can be part of the Attack action instead of a Bonus Action. Once per turn.",
        Push: "On a hit, you can push a Large or smaller creature up to 10 ft away.",
        Sap: "On a hit, the target has disadvantage on its next attack roll before your next turn.",
        Slow: "On a hit, reduce target Speed by 10 ft until your next turn. Does not stack beyond 10 ft.",
        Topple: "On a hit, target makes a Con save (DC 8 + ability mod + prof). Fail: Prone.",
        Vex: "On a hit, you have advantage on your next attack roll vs that creature before your next turn ends.",
      };
      const propertyDescriptions = {
        Ammunition: "Requires ammo. Each attack expends one. You need a free hand to load a one-handed weapon.",
        Finesse: "Use STR or DEX for attack and damage; same mod for both.",
        Heavy: "Disadvantage on attacks if STR < 13 (melee) or DEX < 13 (ranged).",
        Light: "After attacking with a Light weapon, you can make one extra Light-weapon attack as a Bonus Action; no ability mod to that damage unless negative.",
        Loading: "You can fire only one piece of ammo per action/bonus action/reaction.",
        Range: "Normal/long range. Disadvantage beyond normal; can't attack beyond long.",
        Reach: "Adds 5 ft to your reach for attacks and opportunity attacks.",
        Thrown: "Can be thrown; draw it as part of the attack. Use the same ability mod as melee with it.",
        "Two-Handed": "Requires two hands to attack.",
        Versatile: "Use one or two hands. Parentheses show damage when used with two hands.",
      };

      function resolveWeaponName(name) {
        if (weaponByName.has(name)) return name;
        const alias = weaponAliases[name];
        return alias && weaponByName.has(alias) ? alias : name;
      }

      function getWeaponData(name) {
        const resolved = resolveWeaponName(name);
        return weaponByName.get(resolved) || null;
      }

      function getArmorData(name) {
        if (!name) return null;
        return armorByName.get(name) || armorByKey.get(normalizeKey(name)) || null;
      }

      function getDamageDie(damage) {
        if (!damage) return "";
        return damage.split(" ")[0];
      }

      function getVersatileDie(properties) {
        if (!properties) return "";
        const text = String(properties);
        const match =
          text.match(/Versatile\s*\(([^)]+)\)/i) ||
          text.match(/Versatile\s*([0-9]+d[0-9]+)/i);
        if (!match) return "";
        return match[1].trim();
      }

      function isVersatileWeapon(weapon) {
        if (!weapon?.properties) return false;
        return /versatile/i.test(String(weapon.properties));
      }

      function getWeaponDamageDie(weapon, useTwoHands) {
        if (!weapon) return "";
        if (useTwoHands && isVersatileWeapon(weapon)) {
          return getVersatileDie(weapon.properties) || getDamageDie(weapon.damage);
        }
        return getDamageDie(weapon.damage);
      }

      function getTwoHandDamageDie(weapon, useTwoHands) {
        if (!weapon) return "";
        if (!useTwoHands) return getDamageDie(weapon.damage);
        if (isVersatileWeapon(weapon)) {
          return getVersatileDie(weapon.properties) || getDamageDie(weapon.damage);
        }
        return getDamageDie(weapon.damage);
      }

      function getWeaponAttackAbility(weapon) {
        if (!weapon) return "str";
        if (weapon.properties && weapon.properties.includes("Finesse")) return "finesse";
        if (weapon.category && weapon.category.includes("Ranged")) return "dex";
        return "str";
      }

      function isWeaponProficient(weapon) {
        if (!weapon) return false;
        const profs = (currentWeaponProficiencies || [])
          .map((entry) => String(entry || "").toLowerCase());
        if (!profs.length) return false;
        const name = String(weapon.name || "").toLowerCase();
        const category = String(weapon.category || "").toLowerCase();
        const properties = String(weapon.properties || "").toLowerCase();
        if (profs.some((entry) => entry === "all weapons" || entry === "all")) return true;
        if (profs.some((entry) => entry.includes("simple") && category.includes("simple"))) return true;
        if (profs.some((entry) => entry.includes("martial") && category.includes("martial"))) return true;
        if (profs.some((entry) => entry.includes("ranged") && category.includes("ranged"))) return true;
        if (profs.some((entry) => entry.includes("melee") && category.includes("melee"))) return true;
        if (profs.some((entry) => entry.includes("light") && properties.includes("light"))) return true;
        if (profs.some((entry) => entry.includes(name))) return true;
        const normalizedName = name.replace(/[^a-z0-9]+/g, " ").trim();
        if (profs.some((entry) => entry.replace(/[^a-z0-9]+/g, " ").trim() === normalizedName)) {
          return true;
        }
        const nameParts = normalizedName.split(" ").filter(Boolean);
        if (nameParts.length) {
          if (profs.some((entry) => entry.includes(nameParts[0]) && entry.includes(nameParts[nameParts.length - 1]))) {
            return true;
          }
        }
        return false;
      }

      function buildPropertiesTooltip(properties) {
        if (!properties || properties === "") return "No properties.";
        const parts = properties.split(",").map((part) => part.trim());
        return parts
          .map((part) => {
            const base = part.split(" (")[0].trim();
            const desc = propertyDescriptions[base] || "";
            const parenMatch = part.match(/\\(([^)]+)\\)/);
            const extra = parenMatch ? ` Range: ${parenMatch[1]}.` : "";
            return desc ? `${base}: ${desc}${extra}` : part;
          })
          .join(" ");
      }

      function getItemTooltip(label, value, weapon) {
        if (label === "Mastery") {
          return masteryDescriptions[weapon.mastery] || `Mastery: ${weapon.mastery}`;
        }
        if (label === "Properties") {
          return buildPropertiesTooltip(weapon.properties);
        }
        if (label === "Range") {
          return `Range: ${value} (normal/long).`;
        }
        return `${label}: ${value}`;
      }

      function formatSpellLevel(level) {
        if (!level && level !== 0) return "";
        const numeric = Number(level);
        if (Number.isFinite(numeric)) {
          return numeric === 0 ? "Cantrip" : `Level ${numeric}`;
        }
        return String(level);
      }

      function getSpellTooltip(label, value) {
        if (label === "Description") {
          return value || "No description.";
        }
        return `${label}: ${value}`;
      }

      function getRaceData(name) {
        if (!name) return null;
        return raceByName.get(name) || null;
      }

      function getBackgroundData(name) {
        if (!name) return null;
        return backgroundByName.get(name) || null;
      }

      function toDisplayName(value) {
        return String(value || "")
          .replace(/[_-]+/g, " ")
          .split(" ")
          .filter(Boolean)
          .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
          .join(" ");
      }

      function normalizeAbilityKey(value) {
        const key = String(value || "").trim().toLowerCase();
        const map = {
          str: "str",
          strength: "str",
          dex: "dex",
          dexterity: "dex",
          con: "con",
          constitution: "con",
          int: "int",
          intelligence: "int",
          wis: "wis",
          wisdom: "wis",
          cha: "cha",
          charisma: "cha",
        };
        return map[key] || "";
      }

      function abilityKeyToLabel(key) {
        const map = {
          str: "Strength",
          dex: "Dexterity",
          con: "Constitution",
          int: "Intelligence",
          wis: "Wisdom",
          cha: "Charisma",
        };
        return map[key] || key.toUpperCase();
      }

      function extractBackgroundFeatNames(entry) {
        const feats = Array.isArray(entry?.feats) ? entry.feats : [];
        const names = [];
        feats.forEach((group) => {
          if (!group || typeof group !== "object") return;
          Object.keys(group).forEach((raw) => {
            const core = String(raw).split("|")[0].split(";")[0].trim();
            if (core) names.push(toDisplayName(core));
          });
        });
        return names;
      }

      function extractBackgroundSkillNames(entry) {
        const rows = Array.isArray(entry?.skillProficiencies) ? entry.skillProficiencies : [];
        const names = [];
        rows.forEach((group) => {
          if (!group || typeof group !== "object") return;
          Object.entries(group).forEach(([key, value]) => {
            if (key === "choose") return;
            if (value) names.push(toDisplayName(key));
          });
        });
        return names;
      }

      function extractBackgroundToolNames(entry) {
        const rows = Array.isArray(entry?.toolProficiencies) ? entry.toolProficiencies : [];
        const names = [];
        rows.forEach((group) => {
          if (!group || typeof group !== "object") return;
          Object.entries(group).forEach(([key, value]) => {
            if (!value) return;
            names.push(toDisplayName(key));
          });
        });
        return names;
      }

      function formatCoinFromCopper(value) {
        const amount = Number(value);
        if (!Number.isFinite(amount)) return "";
        const gp = amount / 100;
        return `${Number.isInteger(gp) ? gp : gp.toFixed(2)} gp`;
      }

      function getCatalogNameCandidates(name) {
        const raw = String(name || "").trim();
        if (!raw) return [];
        const cleaned = raw
          .replace(/\([^)]*\)/g, " ")
          .replace(/[.;:]+$/g, "")
          .replace(/\s+/g, " ")
          .trim();
        const seeds = new Set([raw, cleaned, toDisplayName(cleaned)]);
        const out = new Set();
        const addVariants = (value) => {
          const base = normalizeKey(value);
          if (!base) return;
          out.add(base);
          if (base.endsWith("ies")) {
            out.add(base.slice(0, -3) + "y");
          }
          if (base.endsWith("ves")) {
            out.add(base.slice(0, -3) + "f");
            out.add(base.slice(0, -3) + "fe");
          }
          if (base.endsWith("es")) {
            out.add(base.slice(0, -2));
          }
          if (base.endsWith("s") && !base.endsWith("ss")) {
            out.add(base.slice(0, -1));
          }
        };
        seeds.forEach((seed) => addVariants(seed));
        return Array.from(out).filter(Boolean);
      }

      function findCatalogEntryByName(name, table = []) {
        if (!name || !Array.isArray(table) || !table.length) return null;
        const candidates = getCatalogNameCandidates(name);
        if (!candidates.length) return null;
        for (const candidate of candidates) {
          const found = table.find((entry) => normalizeKey(entry.name) === candidate);
          if (found) return found;
        }
        return null;
      }

      function resolveCatalogItem(name) {
        const weapon = findCatalogEntryByName(name, weaponTable);
        if (weapon) {
          return { name: weapon.name, isWeapon: true, isArmor: false };
        }
        const armor = findCatalogEntryByName(name, armorTable);
        if (armor) {
          return { name: armor.name, isWeapon: false, isArmor: true };
        }
        const fallbackName = String(name || "").trim();
        const fallbackKey = normalizeKey(fallbackName);
        const armorLike = /\b(armor|shield|mail|breastplate|half plate)\b/.test(fallbackKey);
        return {
          name: toDisplayName(fallbackName),
          isWeapon: false,
          isArmor: armorLike,
        };
      }

      function normalizeCatalogItemName(name) {
        const resolved = resolveCatalogItem(name);
        return resolved.name || name;
      }

      function parseEquipmentChoiceItems(choiceItems = []) {
        const out = [];
        choiceItems.forEach((entry) => {
          if (!entry || typeof entry !== "object") return;
          if (entry.item) {
            const baseRaw = String(entry.item).split("|")[0].trim();
            const display = String(entry.displayName || baseRaw).trim();
            const normalized = normalizeCatalogItemName(toDisplayName(display));
            const qty = Math.max(1, Number(entry.quantity) || 1);
            out.push({ type: "item", name: normalized, qty });
            return;
          }
          if (entry.equipmentType) {
            out.push({ type: "item", name: toDisplayName(entry.equipmentType), qty: 1 });
            return;
          }
          if (entry.value !== undefined && entry.value !== null) {
            const coin = formatCoinFromCopper(entry.value);
            if (coin) out.push({ type: "item", name: coin, qty: 1 });
          }
        });
        return out;
      }

      function parseClassEquipmentLine(line) {
        const text = String(line || "").trim();
        if (!text) return { type: "fixed", value: "" };
        const matches = Array.from(
          text.matchAll(/\(([a-z])\)\s*([^()]+?)(?=(?:,\s*)?\([a-z]\)|$)/gi)
        );
        if (matches.length >= 2) {
          const options = matches
            .map((match) => String(match[2] || "").trim())
            .map((part) =>
              part
                .replace(/^\s*(?:or\s+|and\s+|,\s*)/i, "")
                .replace(/\s*(?:,\s*or|,\s*and|\s+or|\s+and)\s*$/i, "")
                .trim()
            )
            .filter(Boolean);
          if (options.length) {
            return { type: "choice", options };
          }
        }
        const fallbackOptions = text
          .replace(/\(([a-z])\)\s*/gi, "")
          .split(/\s+or\s+/i)
          .map((part) =>
            String(part || "")
              .trim()
              .replace(/^\s*(?:or\s+|and\s+|,\s*)/i, "")
              .replace(/\s*(?:,\s*or|,\s*and|\s+or|\s+and)\s*$/i, "")
              .trim()
          )
          .filter(Boolean);
        if (fallbackOptions.length >= 2) {
          return { type: "choice", options: fallbackOptions };
        }
        return { type: "fixed", value: text };
      }

      function splitClassEquipmentTextToEntries(text) {
        const raw = String(text || "").trim();
        if (!raw) return [];
        return raw
          .split(/\s*,\s*|\s+and\s+/i)
          .map((entry) => entry.replace(/\(if proficient\)/gi, "").trim())
          .filter(Boolean);
      }

      function parseClassEquipmentWeaponRequirement(rawEntry) {
        const normalized = normalizeClassEquipmentEntry(rawEntry);
        const key = normalizeKey(normalized.name);
        const qty = Math.max(1, Number(normalized.qty) || 1);
        if (key === "simple weapon" || key === "simple weapons") {
          return { qty, simple: true, martial: false, melee: false, ranged: false };
        }
        if (key === "simple melee weapon" || key === "simple melee weapons") {
          return { qty, simple: true, martial: false, melee: true, ranged: false };
        }
        if (key === "simple ranged weapon" || key === "simple ranged weapons") {
          return { qty, simple: true, martial: false, melee: false, ranged: true };
        }
        if (key === "martial weapon" || key === "martial weapons") {
          return { qty, simple: false, martial: true, melee: false, ranged: false };
        }
        if (key === "martial melee weapon" || key === "martial melee weapons") {
          return { qty, simple: false, martial: true, melee: true, ranged: false };
        }
        if (key === "martial ranged weapon" || key === "martial ranged weapons") {
          return { qty, simple: false, martial: true, melee: false, ranged: true };
        }
        return null;
      }

      function getClassEquipmentWeaponRequirementFromText(text) {
        const pieces = splitClassEquipmentTextToEntries(text);
        let found = null;
        pieces.forEach((piece) => {
          const requirement = parseClassEquipmentWeaponRequirement(piece);
          if (!requirement) return;
          if (!found) {
            found = { ...requirement };
            return;
          }
          found.qty += requirement.qty;
        });
        return found;
      }

      function getClassEquipmentWeaponCandidates(requirement) {
        if (!requirement) return [];
        return weaponTable
          .filter((weapon) => {
            const category = normalizeKey(weapon.category || "");
            if (requirement.simple && !category.includes("simple")) return false;
            if (requirement.martial && !category.includes("martial")) return false;
            if (requirement.melee && !category.includes("melee")) return false;
            if (requirement.ranged && !category.includes("ranged")) return false;
            return true;
          })
          .map((weapon) => weapon.name)
          .sort((a, b) => a.localeCompare(b));
      }

      function getClassEquipmentWeaponRequirementLabel(requirement) {
        if (!requirement) return "Pick weapon";
        const scope = requirement.simple
          ? "simple"
          : requirement.martial
            ? "martial"
            : "";
        const kind = requirement.melee
          ? "melee"
          : requirement.ranged
            ? "ranged"
            : "";
        const parts = [scope, kind, "weapon"].filter(Boolean);
        return `Pick ${parts.join(" ")}${requirement.qty > 1 ? ` (x${requirement.qty})` : ""}`;
      }

      function getSelectionWeaponPicks(selection, qty = 1) {
        const size = Math.max(1, Number(qty) || 1);
        if (!selection) return Array(size).fill("");
        if (selection.type === "choice") {
          const picksByOption = selection.weaponPicksByOption && typeof selection.weaponPicksByOption === "object"
            ? selection.weaponPicksByOption
            : {};
          const raw = picksByOption[selection.selected];
          const values = Array.isArray(raw) ? raw : [raw];
          return Array.from({ length: size }, (_, idx) => String(values[idx] || "").trim());
        }
        const raw = Array.isArray(selection.weaponPicks)
          ? selection.weaponPicks
          : [selection.weaponPick || ""];
        return Array.from({ length: size }, (_, idx) => String(raw[idx] || "").trim());
      }

      function getSelectionWeaponPick(selection) {
        return getSelectionWeaponPicks(selection, 1)[0] || "";
      }

      function updateClassEquipmentApplyState() {
        if (!classEquipmentApply) return;
        const hasMissingWeaponPick = pendingClassEquipmentSelections.some((selection) => {
          const text = selection.type === "choice"
            ? selection.options?.[selection.selected] || selection.options?.[0] || ""
            : selection.value || "";
          const requirement = getClassEquipmentWeaponRequirementFromText(text);
          if (!requirement) return false;
          const picks = getSelectionWeaponPicks(selection, requirement.qty);
          return picks.some((picked) => !picked);
        });
        classEquipmentApply.disabled = hasMissingWeaponPick;
      }

      function normalizeClassEquipmentEntry(rawEntry) {
        const text = String(rawEntry || "").trim();
        if (!text) return { name: "", qty: 1 };
        const numberWords = {
          one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9, ten: 10,
        };
        const normalized = text
          .replace(/^\s*(?:or|and)\s+/i, "")
          .replace(/\s+(?:or|and)\s*$/i, "")
          .trim()
          .toLowerCase();
        const quantifiable = normalized.replace(/^(a|an|any)\s+/i, "").trim();
        const numMatch = quantifiable.match(/^(\d+)\s+(.+)$/);
        if (numMatch) {
          return { name: toDisplayName(numMatch[2]), qty: Math.max(1, Number(numMatch[1])) };
        }
        const wordMatch = quantifiable.match(/^(one|two|three|four|five|six|seven|eight|nine|ten)\s+(.+)$/);
        if (wordMatch) {
          return { name: toDisplayName(wordMatch[2]), qty: numberWords[wordMatch[1]] || 1 };
        }
        return {
          name: toDisplayName(normalized.replace(/^(a|an|any)\s+/i, "")),
          qty: 1,
        };
      }

      function revertClassStartingEquipmentEffects() {
        if (appliedClassInventoryNames.length) {
          appliedClassInventoryNames.forEach((name) => removeFirstInventoryEntryByName(name));
        }
        appliedClassInventoryNames = [];
        if (appliedClassEquipmentIds.length) {
          equipmentItems = equipmentItems.filter((item) => !appliedClassEquipmentIds.includes(item.id));
          if (appliedClassEquipmentIds.includes(equippedMainId)) equippedMainId = "";
          if (appliedClassEquipmentIds.includes(equippedOffhandId)) equippedOffhandId = "";
          if (appliedClassEquipmentIds.includes(equippedArmorId)) equippedArmorId = "";
          if (appliedClassEquipmentIds.includes(equippedShieldId)) equippedShieldId = "";
        }
        appliedClassEquipmentIds = [];
        appliedClassEquipmentName = "";
      }

      function summarizeEquipmentChoice(choiceItems = []) {
        const parsed = parseEquipmentChoiceItems(choiceItems);
        if (!parsed.length) return "--";
        return parsed
          .map((entry) => (entry.qty > 1 ? `${entry.name} x${entry.qty}` : entry.name))
          .join(", ");
      }

      function getBackgroundAbilityModes(entry) {
        const modes = [];
        const rows = Array.isArray(entry?.ability) ? entry.ability : [];
        rows.forEach((row) => {
          const weighted = row?.choose?.weighted;
          const from = Array.isArray(weighted?.from)
            ? weighted.from.map((value) => normalizeAbilityKey(value)).filter(Boolean)
            : [];
          const weights = Array.isArray(weighted?.weights)
            ? weighted.weights.map((value) => Number(value)).filter((value) => Number.isFinite(value) && value > 0)
            : [];
          if (!from.length || !weights.length) return;
          modes.push({ from, weights });
        });
        return modes;
      }

      function ensureUniqueAbilityAssignments(values = [], fallbackPool = []) {
        const used = new Set();
        return values.map((ability, idx) => {
          if (ability && !used.has(ability)) {
            used.add(ability);
            return ability;
          }
          const next = fallbackPool.find((candidate) => !used.has(candidate));
          if (next) {
            used.add(next);
            return next;
          }
          const backup = fallbackPool[idx] || fallbackPool[0] || "";
          if (backup) used.add(backup);
          return backup;
        });
      }

      function getSkillCheckboxId(skillName) {
        const key = normalizeKey(skillName).replace(/\s+/g, "-");
        return `skill-${key}-prof`;
      }

      function getAllSkillNames() {
        return skillRows
          .map((row) => {
            const checkbox = row.querySelector("input[type='checkbox']");
            if (!checkbox?.id) return "";
            const match = String(checkbox.id).match(/^skill-(.+)-prof$/);
            if (!match) return "";
            return match[1].replace(/-/g, " ");
          })
          .filter(Boolean);
      }

      function getFeatAbilityBonusesFromSelections() {
        const next = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
        forEachAppliedFeatSelection((featName, choiceSelections) => {
          const feat = getFeatData(featName);
          const modifiers = feat?.modifiers && typeof feat.modifiers === "object"
            ? feat.modifiers
            : {};

          const addBonus = (abilityName, amount) => {
            const key = normalizeAbilityKey(abilityName);
            if (!key || !(key in next)) return;
            next[key] += Number(amount) || 0;
          };

          if (modifiers.ability_score_fixed && typeof modifiers.ability_score_fixed === "object") {
            Object.entries(modifiers.ability_score_fixed).forEach(([abilityName, amount]) => {
              addBonus(abilityName, amount);
            });
          }

          const selectedAbilities = Array.isArray(choiceSelections.ability_score_choice)
            ? choiceSelections.ability_score_choice
            : [];
          if (selectedAbilities.length) {
            const count = Math.max(1, Number(modifiers.ability_score_choice_count) || 1);
            const totalBy = Math.max(1, Number(modifiers.ability_score_increase?.by) || 1);
            let perPick = totalBy;
            if (String(featName).toLowerCase() === "ability score improvement" && count >= 2 && totalBy >= 2) {
              perPick = 1;
            } else if (count > 1 && totalBy > 1) {
              perPick = Math.max(1, Math.floor(totalBy / count));
            }
            selectedAbilities.forEach((abilityName) => addBonus(abilityName, perPick));
          }
        });
        return next;
      }

      function recomputeFeatAbilityBonuses() {
        const next = getFeatAbilityBonusesFromSelections();
        const current = normalizeAbilityBonusMap(appliedFeatAbilityBonuses);
        Object.keys(current).forEach((ability) => {
          const delta = (Number(next[ability]) || 0) - (Number(current[ability]) || 0);
          if (!delta || !abilityScores[ability]) return;
          const score = toNumber(getListValue(abilityScores[ability]));
          setListValue(abilityScores[ability], String(score + delta));
        });
        appliedFeatAbilityBonuses = next;
      }

      function getFeatGrantedSkillIds() {
        const ids = new Set();
        forEachAppliedFeatSelection((featName, choiceSelections) => {
          const feat = getFeatData(featName);
          const modifiers = feat?.modifiers && typeof feat.modifiers === "object"
            ? feat.modifiers
            : {};

          const addSkillId = (value) => {
            const raw = String(value || "").trim();
            if (!raw) return;
            const lower = raw.toLowerCase();
            if (["any_skill", "anyskill", "any_tool", "anytool", "any_proficient_skill"].includes(lower)) return;
            const id = getSkillCheckboxId(raw);
            if (document.getElementById(id)) {
              ids.add(id);
            }
          };

          if (Array.isArray(modifiers.skill_proficiency_granted)) {
            modifiers.skill_proficiency_granted.forEach(addSkillId);
          }

          ["skill_proficiency_choice", "skill_proficiency_or_expertise_choice", "skill_tool_choice"]
            .forEach((choiceKey) => {
              const selected = Array.isArray(choiceSelections[choiceKey]) ? choiceSelections[choiceKey] : [];
              selected.forEach(addSkillId);
            });
        });
        return Array.from(ids);
      }

      function updateAllSkillProficiencies() {
        const nextIds = new Set([
          ...appliedBackgroundSkillIds,
          ...getFeatGrantedSkillIds(),
        ]);
        skillRows.forEach((row) => {
          const checkbox = row.querySelector("input[type='checkbox']");
          if (!checkbox) return;
          checkbox.checked = nextIds.has(checkbox.id);
          checkbox.disabled = true;
        });
      }

      function setBackgroundSkillProficiencies(skillNames = []) {
        const nextIds = skillNames
          .map((name) => getSkillCheckboxId(name))
          .filter(Boolean);
        appliedBackgroundSkillIds = nextIds.slice();
        updateAllSkillProficiencies();
      }

      function removeFirstInventoryEntryByName(name) {
        const key = normalizeKey(name);
        const idx = inventoryItems.findIndex((entry) => normalizeKey(entry) === key);
        if (idx >= 0) {
          inventoryItems.splice(idx, 1);
        }
      }

      function revertBackgroundEffects() {
        Object.entries(appliedBackgroundAbilityBonuses).forEach(([ability, bonus]) => {
          if (!bonus || !abilityScores[ability]) return;
          const current = toNumber(getListValue(abilityScores[ability]));
          setListValue(abilityScores[ability], String(current - bonus));
        });
        appliedBackgroundAbilityBonuses = {
          str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0,
        };

        appliedBackgroundSkillIds = [];
        updateAllSkillProficiencies();

        if (appliedBackgroundInventoryNames.length) {
          appliedBackgroundInventoryNames.forEach((name) => removeFirstInventoryEntryByName(name));
        }
        appliedBackgroundInventoryNames = [];

        if (appliedBackgroundEquipmentIds.length) {
          equipmentItems = equipmentItems.filter((item) => !appliedBackgroundEquipmentIds.includes(item.id));
          if (appliedBackgroundEquipmentIds.includes(equippedMainId)) equippedMainId = "";
          if (appliedBackgroundEquipmentIds.includes(equippedOffhandId)) equippedOffhandId = "";
          if (appliedBackgroundEquipmentIds.includes(equippedArmorId)) equippedArmorId = "";
          if (appliedBackgroundEquipmentIds.includes(equippedShieldId)) equippedShieldId = "";
        }
        appliedBackgroundEquipmentIds = [];
        appliedBackgroundFeatNames = [];
        appliedBackgroundFeatChoiceSelections = {};
        appliedBackgroundName = "";
        rebuildSelectedFeatItems();
        recomputeFeatAbilityBonuses();
        renderTraitsList();
        updateAllSkillProficiencies();
        buildCantripPickerList(spellSearch?.value || "");
      }

      function setSizePickerOpen(isOpen) {
        if (!sizePicker) return;
        sizePicker.classList.toggle("open", isOpen);
        sizePicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
      }

      function setAlignmentPickerOpen(isOpen) {
        if (!alignmentPicker) return;
        if (!isOpen && subclassPickerLocked) return;
        const lockedOpen = Boolean(subclassPickerLocked && isOpen);
        alignmentPicker.classList.toggle("open", isOpen);
        alignmentPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        alignmentPicker.classList.toggle("locked", lockedOpen);
        document.body.classList.toggle("subclass-picker-modal-open", lockedOpen);
        if (isOpen) {
          if (alignmentPickerAdd) {
            alignmentPickerAdd.disabled = !pendingSubclassSelection;
          }
          return;
        }
        pendingSubclassOptions = [];
        pendingSubclassSelection = "";
        pendingSubclassSelectionHandler = null;
        pendingSubclassFinalizeEntry = null;
        if (alignmentPickerAdd) {
          alignmentPickerAdd.disabled = true;
        }
      }

      function setAbilityPickerInteractivityLock(lockedOpen) {
        const shouldLock = Boolean(lockedOpen);
        Array.from(document.body.children).forEach((child) => {
          if (child === abilityPicker || child.tagName === "SCRIPT") return;
          if (shouldLock) {
            child.setAttribute("inert", "");
            if (!child.hasAttribute("aria-hidden")) {
              child.setAttribute("aria-hidden", "true");
              child.dataset.abilityLockHidden = "1";
            }
            return;
          }
          child.removeAttribute("inert");
          if (child.dataset.abilityLockHidden === "1") {
            child.removeAttribute("aria-hidden");
            delete child.dataset.abilityLockHidden;
          }
        });
      }

      function setAbilityPickerOpen(isOpen) {
        if (!abilityPicker) return;
        if (!isOpen && abilityPickerLocked) return;
        const lockedOpen = Boolean(abilityPickerLocked && isOpen);
        abilityPicker.classList.toggle("open", isOpen);
        abilityPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        abilityPicker.classList.toggle("locked", lockedOpen);
        document.body.classList.toggle("ability-picker-modal-open", lockedOpen);
        setAbilityPickerInteractivityLock(lockedOpen);
        if (!isOpen) {
          suppressAbilityScoreDefaults = false;
          applyBaseDefaults();
          recalcDerived();
        }
      }

      async function loadTraits() {
        try {
          const snapshot = await getDocs(collection(db, "traits"));
          const rows = snapshot.docs
            .map((docSnap) => {
              const data = docSnap.data() || {};
              const name = firstNonBlank([data.name, data.trait, data.title, docSnap.id]);
              if (!name) return null;
              const description = firstNonBlank([
                data.description,
                data.desc,
                data.details,
                data.text,
                data["trait description"],
                data.body,
              ]);
              return { name, description };
            })
            .filter(Boolean);
          traitByName = new Map();
          rows.forEach((row) => {
            traitByName.set(row.name, row);
            traitByName.set(normalizeKey(row.name), row);
          });
          traitsLoaded = true;
        } catch (error) {
          console.error("Failed to load traits", error);
          traitsLoaded = true;
        }
      }

      function refreshFeatIndex() {
        featByName = new Map();
        featTable.forEach((feat) => {
          featByName.set(feat.name, feat);
          featByName.set(normalizeKey(feat.name), feat);
        });
        featList = featTable.map((feat) => feat.name);
      }

      async function loadFeatsFromFirestore() {
        try {
          const snapshot = await getDocs(collection(db, "feats"));
          const rows = snapshot.docs
            .map((docSnap) => {
              const data = docSnap.data() || {};
              const name = firstNonBlank([data.name, data.title, data.feat, docSnap.id]);
              if (!name) return null;
              const features = Array.isArray(data.features)
                ? data.features
                    .map((entry) => {
                      if (!entry || typeof entry !== "object") return null;
                      const title = firstNonBlank([entry.title, entry.name, "Feature"]);
                      const description = firstNonBlank([entry.description, entry.text, entry.details]);
                      if (!title && !description) return null;
                      return { title, description };
                    })
                    .filter(Boolean)
                : [];
              const description = firstNonBlank([
                data.description,
                data.desc,
                data.details,
                data.text,
                data.body,
              ]);
              return {
                name,
                source: firstNonBlank([data.source]),
                modifiers: data.modifiers && typeof data.modifiers === "object" ? data.modifiers : {},
                features,
                description,
              };
            })
            .filter(Boolean);
          featTable = rows;
          refreshFeatIndex();
          featsLoaded = true;
        } catch (error) {
          console.error("Failed to load feats", error);
          featTable = [];
          refreshFeatIndex();
          featsLoaded = true;
        }
      }

      function getTraitData(name) {
        if (!name) return null;
        return traitByName.get(name) || traitByName.get(normalizeKey(name)) || null;
      }

      function getFeatData(name) {
        if (!name) return null;
        return featByName.get(name) || featByName.get(normalizeKey(name)) || null;
      }

      function getItemDataByName(name) {
        if (!name) return null;
        return itemByName.get(name) || itemByName.get(normalizeKey(name)) || null;
      }

      function openTraitPanel(name) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !name) return;
        const trait = getTraitData(name);
        const description = trait?.description || "No description found in Firestore traits table.";
        itemPanelTitle.textContent = trait?.name || name;
        itemPanelBody.innerHTML = "";
        const rows = [
          ["Trait", trait?.name || name],
          ["Description", description],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", `${label}: ${value}`);
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function openFeatPanel(name) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !name) return;
        const feat = getFeatData(name);
        itemPanelTitle.textContent = feat?.name || name;
        itemPanelBody.innerHTML = "";

        const primaryDescription = String(feat?.description || "").trim();
        const descriptionFromFeatures = Array.isArray(feat?.features)
          ? (
            feat.features.find((entry) => String(entry?.title || "").trim().toLowerCase() === "description")
              ?.description
            || feat.features.find((entry) => String(entry?.description || "").trim())
              ?.description
            || ""
          )
          : "";
        const resolvedDescription = primaryDescription || String(descriptionFromFeatures || "").trim() || "--";

        const featureSummary = Array.isArray(feat?.features)
          ? feat.features
              .map((entry) => [entry.title, entry.description].filter(Boolean).join(": "))
              .filter(Boolean)
              .join(" | ")
          : "";
        const rows = [
          ["Feat", feat?.name || name],
          ["Source", feat?.source || "--"],
          ["Description", resolvedDescription],
          ["Features", featureSummary || "--"],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", `${label}: ${value}`);
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function renderTraitsList() {
        if (!traitsListEl) return;
        traitsListEl.innerHTML = "";

        currentRaceTraits.filter(Boolean).forEach((trait) => {
          const item = document.createElement("li");
          item.textContent = trait;
          item.classList.add("trait-clickable");
          item.setAttribute("role", "button");
          item.setAttribute("tabindex", "0");
          const open = () => openTraitPanel(trait);
          item.addEventListener("click", open);
          item.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              open();
            }
          });
          traitsListEl.appendChild(item);
        });

        currentClassProgressionFeatures.forEach((feature) => {
          const item = document.createElement("li");
          item.textContent = `Class (Lv ${feature.level}): ${feature.name}`;
          item.classList.add("trait-clickable");
          item.setAttribute("role", "button");
          item.setAttribute("tabindex", "0");
          const open = () => openClassFeaturePanel(feature.name, feature.level);
          item.addEventListener("click", open);
          item.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              open();
            }
          });
          traitsListEl.appendChild(item);
        });

        FEAT_LEVEL_MILESTONES.forEach((level) => {
          const featName = String(featSelectionsByLevel[String(level)] || "").trim();
          if (!featName) return;
          const choiceSummary = getFeatChoiceSummary(level);
          const item = document.createElement("li");
          item.textContent = choiceSummary
            ? `Feat (Lv ${level}): ${featName} [${choiceSummary}]`
            : `Feat (Lv ${level}): ${featName}`;
          item.classList.add("trait-clickable");
          item.setAttribute("role", "button");
          item.setAttribute("tabindex", "0");
          const open = () => openFeatPanel(featName);
          item.addEventListener("click", open);
          item.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              open();
            }
          });
          traitsListEl.appendChild(item);
        });

        normalizeFeatNameList(appliedBackgroundFeatNames).forEach((featName) => {
          const item = document.createElement("li");
          item.textContent = `Feat (Background): ${featName}`;
          item.classList.add("trait-clickable");
          item.setAttribute("role", "button");
          item.setAttribute("tabindex", "0");
          const open = () => openFeatPanel(featName);
          item.addEventListener("click", open);
          item.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              open();
            }
          });
          traitsListEl.appendChild(item);
        });
      }

      function openInventoryItemPanel(name) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !name) return;
        const item = getItemDataByName(name);
        itemPanelTitle.textContent = item?.name || name;
        itemPanelBody.innerHTML = "";
        const rows = [
          ["Name", item?.name || name],
          ["Description", item?.description || "--"],
          ["Gold Value", formatGoldValue(item?.goldValue)],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", `${label}: ${value}`);
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      const standardArrayValues = [15, 14, 13, 12, 10, 8];
      let pendingClassEntry = null;
      let pendingAbilityValues = [];
      let pendingAbilitySelection = null;
      let abilityMethod = "standard";
      let currentRollValues = [];
      let abilityPickerLocked = false;
      let racePickerLocked = false;
      let classPickerLocked = false;
      let subclassPickerLocked = false;
      let backgroundPickerLocked = false;
      let backgroundConfigLocked = false;
      let pendingSubclassFinalizeEntry = null;
      let pendingSubclassSelectionHandler = null;
      let pendingSubclassOptions = [];
      let pendingSubclassSelection = "";
      let pendingBackgroundClassEntry = null;
      let requireBackgroundAfterClassEquipment = false;
      let newCharacterSetupFlowActive = false;
      let selectedRaceSubclass = "";

      function roll4d6DropLowest() {
        const rolls = [];
        for (let i = 0; i < 4; i += 1) {
          rolls.push(Math.floor(Math.random() * 6) + 1);
        }
        rolls.sort((a, b) => a - b);
        return rolls.slice(1).reduce((sum, value) => sum + value, 0);
      }

      function resetAbilityAssignments() {
        Object.values(abilityScores).forEach((el) => {
          setListValue(el, "");
        });
        recalcDerived();
      }

      function buildAbilityPicker() {
        if (!abilityValuesEl || !abilityChoicesEl || !abilityOptionsEl) return;
        abilityValuesEl.innerHTML = "";
        abilityChoicesEl.innerHTML = "";
        abilityOptionsEl.innerHTML = "";

        const optionDefs = [
          { key: "standard", label: "Standard Array", enabled: true },
          { key: "pointbuy", label: "Point Buy", enabled: false },
          { key: "roll", label: "Roll", enabled: true },
        ];
        optionDefs.forEach((opt) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.textContent = opt.label;
          btn.disabled = !opt.enabled;
          if (abilityMethod === opt.key) {
            btn.classList.add("selected");
          }
          btn.addEventListener("click", () => {
            if (!opt.enabled) return;
            abilityMethod = opt.key;
            if (abilityMethod === "standard") {
              pendingAbilityValues = standardArrayValues.slice();
              pendingAbilitySelection = null;
            }
            if (abilityMethod === "roll") {
              pendingAbilitySelection = null;
              if (!currentRollValues.length) {
                currentRollValues = Array.from({ length: 6 }, () => ({
                  id: `roll_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
                  value: roll4d6DropLowest(),
                }));
              }
            }
            buildAbilityPicker();
          });
          abilityOptionsEl.appendChild(btn);
        });

        if (abilityMethod !== "standard") {
          if (abilityMethod === "roll") {
            if (!currentRollValues.length) {
              const rollBtn = document.createElement("button");
              rollBtn.type = "button";
              rollBtn.textContent = "Roll 4d6 (drop lowest) x6";
              rollBtn.addEventListener("click", () => {
                currentRollValues = Array.from({ length: 6 }, () => ({
                  id: `roll_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
                  value: roll4d6DropLowest(),
                }));
                pendingAbilitySelection = null;
                buildAbilityPicker();
              });
              abilityValuesEl.appendChild(rollBtn);
            }

            currentRollValues.forEach((entry) => {
              const btn = document.createElement("button");
              btn.type = "button";
              btn.textContent = String(entry.value);
              if (pendingAbilitySelection && pendingAbilitySelection.id === entry.id) {
                btn.classList.add("selected");
              }
              btn.addEventListener("click", () => {
                pendingAbilitySelection = { id: entry.id, value: entry.value };
                buildAbilityPicker();
              });
              abilityValuesEl.appendChild(btn);
            });
          }
        } else {
          pendingAbilityValues.forEach((value) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.textContent = String(value);
            if (pendingAbilitySelection === value) {
              btn.classList.add("selected");
            }
            btn.addEventListener("click", () => {
              pendingAbilitySelection = value;
              buildAbilityPicker();
            });
            abilityValuesEl.appendChild(btn);
          });
        }

        if (abilityMethod !== "standard" && abilityMethod !== "roll") {
          return;
        }

        const abilityLabels = [
          ["str", "Strength"],
          ["dex", "Dexterity"],
          ["con", "Constitution"],
          ["int", "Intelligence"],
          ["wis", "Wisdom"],
          ["cha", "Charisma"],
        ];
        abilityLabels.forEach(([key, label]) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.textContent = label;
          const scoreEl = abilityScores[key];
          if (scoreEl && getListValue(scoreEl)) {
            btn.disabled = true;
          }
          btn.addEventListener("click", () => {
            if (!pendingAbilitySelection || !scoreEl || getListValue(scoreEl)) return;
            const selectedValue =
              typeof pendingAbilitySelection === "object"
                ? pendingAbilitySelection.value
                : pendingAbilitySelection;
            setListValue(scoreEl, String(selectedValue));
            if (abilityMethod === "standard") {
              pendingAbilityValues = pendingAbilityValues.filter((v) => v !== pendingAbilitySelection);
            }
            if (abilityMethod === "roll") {
              currentRollValues = currentRollValues.filter(
                (entry) => entry.id !== pendingAbilitySelection.id
              );
            }
            pendingAbilitySelection = null;
            recalcDerived();
            const allFilled = Object.values(abilityScores).every((el) => Boolean(getListValue(el)));
            if (allFilled) {
              abilityPickerLocked = false;
              setAbilityPickerOpen(false);
              if (pendingClassEntry) {
                finalizeClassSelection(pendingClassEntry);
                pendingClassEntry = null;
              } else {
                startRequiredRaceSelection();
              }
              return;
            }
            buildAbilityPicker();
          });
          abilityChoicesEl.appendChild(btn);
        });
      }

      function openAbilityPickerForClass(entry) {
        abilityPickerLocked = false;
        pendingClassEntry = entry;
        suppressAbilityScoreDefaults = true;
        pendingAbilityValues = standardArrayValues.slice();
        pendingAbilitySelection = null;
        abilityMethod = "standard";
        currentRollValues = [];
        resetAbilityAssignments();
        buildAbilityPicker();
        setAbilityPickerOpen(true);
      }

      function openAbilityPickerForNewCharacter() {
        abilityPickerLocked = true;
        pendingClassEntry = null;
        newCharacterSetupFlowActive = true;
        pendingBackgroundClassEntry = null;
        suppressAbilityScoreDefaults = true;
        pendingAbilityValues = [];
        pendingAbilitySelection = null;
        abilityMethod = "roll";
        currentRollValues = Array.from({ length: 6 }, () => ({
          id: `roll_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
          value: roll4d6DropLowest(),
        }));
        resetAbilityAssignments();
        buildAbilityPicker();
        setAbilityPickerOpen(true);
      }

      function startRequiredRaceSelection() {
        racePickerLocked = true;
        setRacePickerOpen(true);
        buildRacePickerList(raceSearch?.value || "");
        raceSearch?.focus();
      }

      function startRequiredClassSelection() {
        classPickerLocked = true;
        setClassPickerOpen(true);
        buildClassPickerList(classSearch?.value || "");
        classSearch?.focus();
      }

      function startRequiredBackgroundSelection() {
        backgroundPickerLocked = true;
        setBackgroundPickerOpen(true);
        buildBackgroundPickerList(backgroundSearch?.value || "");
        backgroundSearch?.focus();
      }

      function getClassSubclassNames(entry) {
        if (!entry || !Array.isArray(entry.subclasses)) return [];
        return entry.subclasses
          .map((sub) => {
            if (sub && typeof sub === "object") return String(sub.name || "").trim();
            return String(sub || "").trim();
          })
          .filter(Boolean);
      }

      function getClassSubclassOptions(entry) {
        if (!entry || !Array.isArray(entry.subclasses)) return [];
        return entry.subclasses
          .map((sub) => {
            if (sub && typeof sub === "object") {
              return {
                name: String(sub.name || "").trim(),
                description: String(sub.description || "").trim(),
                source: entry.name || "Class",
              };
            }
            return {
              name: String(sub || "").trim(),
              description: "",
              source: entry.name || "Class",
            };
          })
          .filter((option) => option.name);
      }

      function getRaceSubclassNames(entry) {
        if (!entry || !Array.isArray(entry.subclass)) return [];
        return entry
          .subclass
          .map((sub) => String(sub || "").trim())
          .filter(Boolean);
      }

      function getRaceSubclassOptions(entry) {
        if (!entry || !Array.isArray(entry.subclass)) return [];
        return entry.subclass
          .map((sub) => ({
            name: String(sub || "").trim(),
            description: "",
            source: entry.name || "Race",
          }))
          .filter((option) => option.name);
      }

      function syncSubclassInputForClass(entry) {
        if (!subclassInput) return;
        const names = getClassSubclassNames(entry);
        subclassInput.disabled = !entry || !names.length;
        if (!names.length) {
          subclassInput.value = "";
          return;
        }
        const current = String(subclassInput.value || "").trim();
        if (current && !names.includes(current)) {
          subclassInput.value = "";
        }
      }

      function openSubclassPanel(option) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !option) return;
        itemPanelTitle.textContent = option.name || "Subclass";
        itemPanelBody.innerHTML = "";
        const rows = [
          ["Description", option.description || "No description available."],
          ["Source", option.source || "--"],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", `${label}: ${value}`);
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function commitPendingSubclassSelection() {
        if (!pendingSubclassSelection) return;
        const handler = pendingSubclassSelectionHandler;
        const selected = pendingSubclassSelection;
        subclassPickerLocked = false;
        setAlignmentPickerOpen(false);
        scheduleSave();
        if (handler) handler(selected);
      }

      function openSubclassChoicePicker(options, {
        title = "Choose subclass",
        required = false,
        currentValue = "",
        onSelect = null,
      } = {}) {
        const normalized = Array.isArray(options)
          ? options
            .map((sub) => {
              if (sub && typeof sub === "object") {
                return {
                  name: String(sub.name || "").trim(),
                  description: String(sub.description || "").trim(),
                  source: String(sub.source || "").trim(),
                };
              }
              return { name: String(sub || "").trim(), description: "", source: "" };
            })
            .filter((sub) => sub.name)
          : [];
        if (!normalized.length) return false;
        pendingSubclassOptions = normalized;
        pendingSubclassSelectionHandler = typeof onSelect === "function" ? onSelect : null;
        subclassPickerLocked = Boolean(required);
        pendingSubclassSelection = normalized.some((option) => option.name === currentValue)
          ? currentValue
          : "";
        if (alignmentPickerTitle) {
          alignmentPickerTitle.textContent = title;
        }
        if (!alignmentPickerList) return;
        alignmentPickerList.innerHTML = "";
        const list = document.createElement("div");
        list.className = "weapon-list";
        normalized.forEach((optionData) => {
          const subclassName = optionData.name;
          const option = document.createElement("div");
          option.className = "weapon-option";
          if (pendingSubclassSelection === subclassName) {
            option.classList.add("selected");
          }
          option.textContent = subclassName;
          option.addEventListener("click", () => {
            pendingSubclassSelection = subclassName;
            openSubclassPanel(optionData);
            if (alignmentPickerAdd) {
              alignmentPickerAdd.disabled = false;
            }
            openSubclassChoicePicker(normalized, {
              title,
              required,
              currentValue: pendingSubclassSelection,
              onSelect,
            });
          });
          list.appendChild(option);
        });
        alignmentPickerList.appendChild(list);
        if (alignmentPickerAdd) {
          alignmentPickerAdd.disabled = !pendingSubclassSelection;
        }
        if (pendingSubclassSelection) {
          const selected = normalized.find((option) => option.name === pendingSubclassSelection);
          if (selected) {
            openSubclassPanel(selected);
          }
        }
        setAlignmentPickerOpen(true);
        return true;
      }

      function openAlignmentPicker(entry, { required = false, finalizeOnPick = false } = {}) {
        const subclassOptions = getClassSubclassOptions(entry);
        if (!subclassOptions.length) return;
        pendingSubclassFinalizeEntry = finalizeOnPick ? entry : null;
        openSubclassChoicePicker(subclassOptions, {
          title: "Choose subclass",
          required,
          currentValue: String(subclassInput?.value || "").trim(),
          onSelect: (subclassName) => {
            if (subclassInput) {
              subclassInput.value = subclassName;
            }
            const finalizeEntry = pendingSubclassFinalizeEntry;
            pendingSubclassFinalizeEntry = null;
            if (finalizeEntry) {
              finalizeClassSelection(finalizeEntry);
            }
          },
        });
      }

      function openRaceSubclassPicker(entry, { required = false, onComplete = null } = {}) {
        const raceSubclassOptions = getRaceSubclassOptions(entry);
        if (!raceSubclassOptions.length) {
          if (typeof onComplete === "function") onComplete();
          return;
        }
        openSubclassChoicePicker(raceSubclassOptions, {
          title: "Choose race subclass",
          required,
          currentValue: String(selectedRaceSubclass || "").trim(),
          onSelect: (subclassName) => {
            selectedRaceSubclass = subclassName;
            if (typeof onComplete === "function") onComplete();
          },
        });
      }

      function openSizePicker(options) {
        if (!sizePickerList) return;
        sizeSelected = "";
        sizePickerList.innerHTML = "";
        const list = document.createElement("div");
        list.className = "weapon-list";
        options.forEach((size) => {
          const option = document.createElement("div");
          option.className = "weapon-option";
          option.textContent = size;
          option.addEventListener("click", () => {
            sizeSelected = size;
            if (sizeInput) {
              sizeInput.value = size;
            }
            setSizePickerOpen(false);
            scheduleSave();
          });
          list.appendChild(option);
        });
        sizePickerList.appendChild(list);
        setSizePickerOpen(true);
      }

      function applyRaceSelection(raceName, { promptForSize = false } = {}) {
        if (!racesLoaded) return;
        if (!raceName) {
          currentRaceSpeed = "";
          currentRaceSizes = [];
          currentRaceTraits = [];
          selectedRaceSubclass = "";
          if (speedInput) setListValue(speedInput, "");
          if (sizeInput) sizeInput.value = "";
          renderTraitsList();
          buildCantripPickerList(spellSearch?.value || "");
          return;
        }
        const race = getRaceData(raceName);
        if (!race) return;
        const raceSubclasses = getRaceSubclassNames(race);
        if (!raceSubclasses.includes(selectedRaceSubclass)) {
          selectedRaceSubclass = "";
        }
        const speedValue = normalizeRaceSpeed(race.speed);
        currentRaceSpeed = speedValue;
        if (speedInput) {
          setListValue(speedInput, speedValue !== "" ? String(speedValue) : "");
        }
        const sizes = normalizeRaceSizes(race.size);
        currentRaceSizes = sizes;
        currentRaceTraits = Array.isArray(race.traits) ? race.traits.slice().filter(Boolean) : [];
        renderTraitsList();
        if (sizes.length <= 1) {
          if (sizeInput) sizeInput.value = sizes[0] || "";
          buildCantripPickerList(spellSearch?.value || "");
          return;
        }
        if (promptForSize) {
          openSizePicker(sizes);
          buildCantripPickerList(spellSearch?.value || "");
          return;
        }
        if (sizeInput && (!sizeInput.value || !sizes.includes(sizeInput.value))) {
          sizeInput.value = sizes[0];
        }
        buildCantripPickerList(spellSearch?.value || "");
      }

      function rollDiceDetailed(dice) {
        if (!dice) return 0;
        if (/^\d+$/.test(dice)) {
          const value = Number(dice);
          return { total: value, rolls: [value] };
        }
        const match = dice.match(/(\d+)d(\d+)/i);
        if (!match) return { total: 0, rolls: [] };
        const count = Number(match[1]);
        const sides = Number(match[2]);
        let total = 0;
        const rolls = [];
        for (let i = 0; i < count; i += 1) {
          const roll = Math.floor(Math.random() * sides) + 1;
          rolls.push(roll);
          total += roll;
        }
        return { total, rolls };
      }

      function playDiceSound(onEnded = null) {
        if (!diceSoundEl) return;
        if (typeof onEnded === "function") {
          diceSoundEl.onended = () => {
            diceSoundEl.onended = null;
            onEnded();
          };
        } else {
          diceSoundEl.onended = null;
        }
        diceSoundEl.currentTime = 0;
        const playPromise = diceSoundEl.play();
        if (playPromise && typeof playPromise.catch === "function") {
          playPromise.catch(() => {
            if (typeof onEnded === "function") onEnded();
          });
        }
      }

      function playSpellCastSound() {
        if (!spellCastSoundEl) return;
        spellCastSoundEl.currentTime = 0;
        const playPromise = spellCastSoundEl.play();
        if (playPromise && typeof playPromise.catch === "function") {
          playPromise.catch(() => {});
        }
      }

      function playWeaponSound() {
        if (!weaponSoundEl) return;
        weaponSoundEl.currentTime = 0;
        const playPromise = weaponSoundEl.play();
        if (playPromise && typeof playPromise.catch === "function") {
          playPromise.catch(() => {});
        }
      }

      function normalizeHitDie(die) {
        const text = String(die || "").trim();
        if (!text) return "";
        if (/^\d+d\d+$/i.test(text)) return text;
        if (/^d\d+$/i.test(text)) return `1${text}`;
        return text;
      }

      function getMaxDieValue(dice) {
        if (!dice) return 0;
        const match = String(dice).match(/(\d+)d(\d+)/i);
        if (!match) return 0;
        const count = Number(match[1]);
        const sides = Number(match[2]);
        if (!Number.isFinite(count) || !Number.isFinite(sides)) return 0;
        return count * sides;
      }

      function getFixedHpPerLevel(entry) {
        const die = normalizeHitDie(entry?.hitPointPerAdditionalLevelDie || entry?.hitPointDie);
        if (!die) return 0;
        const match = String(die).match(/(\d+)d(\d+)/i);
        if (!match) return 0;
        const count = Number(match[1]);
        const sides = Number(match[2]);
        if (!Number.isFinite(count) || !Number.isFinite(sides)) return 0;
        return count * (Math.floor(sides / 2) + 1);
      }

      function updateTotalHpForClass(entry, mods = {}) {
        if (!entry || !totalHpInput) return;
        const level = Math.min(Math.max(toNumber(getListValue(levelEl)) || 1, 1), 20);
        const conMod =
          mods.con ?? computeAbilityMod(toNumber(getListValue(abilityScores.con)));
        const levelOneDie = normalizeHitDie(entry?.hitPointDie || entry?.hitPointPerAdditionalLevelDie);
        const levelOneMax = getMaxDieValue(levelOneDie);
        const fixedAverage = getFixedHpPerLevel(entry);
        if (!levelOneMax || !fixedAverage) return;
        const levelOneTotal = Math.max(1, levelOneMax + conMod);
        const perLevelGain = Math.max(1, fixedAverage + conMod);
        const total = levelOneTotal + Math.max(0, level - 1) * perLevelGain;
        setListValue(totalHpInput, String(total));
        if (currentHpInput) {
          const current = toNumber(currentHpInput.value);
          if (!currentHpInput.value || current === 0 || current > total) {
            currentHpInput.value = String(total);
          }
        }
      }

      function toProgressionNumber(value) {
        const num = Number(value);
        return Number.isFinite(num) ? num : null;
      }

      function getCurrentCharacterLevel() {
        return Math.min(Math.max(toNumber(getListValue(levelEl)) || 1, 1), 20);
      }

      function getClassProgressionSource(className) {
        const key = String(className || "").trim();
        if (!key) return null;
        return classLevelUpByName.get(key) || classLevelUpByName.get(normalizeKey(key)) || null;
      }

      function getClassProgressionEntry(className, level) {
        const source = getClassProgressionSource(className);
        const levelKey = String(Math.min(Math.max(Number(level) || 1, 1), 20));
        if (!source || typeof source !== "object" || !source.progression || typeof source.progression !== "object") {
          return null;
        }
        const entry = source.progression[levelKey];
        return entry && typeof entry === "object" ? entry : null;
      }

      function getCurrentClassProgressionEntry() {
        const className = String(classInput?.value || "").trim();
        if (!className) return null;
        return getClassProgressionEntry(className, getCurrentCharacterLevel());
      }

      function getClassCantripCapForCurrentLevel() {
        const className = String(classInput?.value || "").trim();
        if (!className) return 0;
        const entry = getCurrentClassProgressionEntry();
        if (!entry) return 0;
        if (!Object.prototype.hasOwnProperty.call(entry, "cantrips")) return 0;
        return toProgressionNumber(entry.cantrips);
      }

      function getClassSpellSlotCountsForEntry(entry) {
        const out = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0 };
        if (!entry || typeof entry !== "object") return out;
        const pactSlots = toProgressionNumber(entry.spell_slots);
        const pactSlotLevel = toProgressionNumber(entry.slot_level);
        if (pactSlots !== null && pactSlotLevel !== null && pactSlotLevel >= 1 && pactSlotLevel <= 9) {
          out[pactSlotLevel] = Math.max(0, Math.floor(pactSlots));
          return out;
        }
        const slotKeys = [
          ["1st", 1], ["2nd", 2], ["3rd", 3], ["4th", 4], ["5th", 5],
          ["6th", 6], ["7th", 7], ["8th", 8], ["9th", 9],
        ];
        slotKeys.forEach(([key, slotLevel]) => {
          const value = toProgressionNumber(entry[key]);
          out[slotLevel] = value === null ? 0 : Math.max(0, Math.floor(value));
        });
        return out;
      }

      function getClassSpellSlotCountsForCurrentLevel() {
        return getClassSpellSlotCountsForEntry(getCurrentClassProgressionEntry());
      }

      function getLearnedSpellCountForLevel(level) {
        if (level === 1) return spellLevel1Items.length;
        if (level === 2) return spellLevel2Items.length;
        if (level === 3) return spellLevel3Items.length;
        return cantripItems.length;
      }

      function getSpellLearnCapForLevel(level) {
        if (level === 0) {
          const cap = getClassCantripCapForCurrentLevel();
          return Number.isFinite(cap) ? Math.max(0, Math.floor(cap)) : 0;
        }
        const slotCounts = getClassSpellSlotCountsForCurrentLevel();
        return Math.max(0, Math.floor(Number(slotCounts[level]) || 0));
      }

      function canLearnAnotherSpellAtLevel(level) {
        const cap = getSpellLearnCapForLevel(level);
        const learned = getLearnedSpellCountForLevel(level);
        return learned < cap;
      }

      function getCumulativeClassFeatures(className, level) {
        const source = getClassProgressionSource(className);
        if (!source || typeof source !== "object" || !source.progression || typeof source.progression !== "object") {
          return [];
        }
        const maxLevel = Math.min(Math.max(Number(level) || 1, 1), 20);
        const features = [];
        const seen = new Set();
        for (let i = 1; i <= maxLevel; i += 1) {
          const row = source.progression[String(i)];
          const rowFeatures = Array.isArray(row?.features) ? row.features : [];
          rowFeatures.forEach((featureName) => {
            const name = String(featureName || "").trim();
            if (!name || name === "") return;
            const key = normalizeKey(name);
            if (!key || seen.has(key)) return;
            seen.add(key);
            features.push({ name, level: i });
          });
        }
        return features;
      }

      function openClassFeaturePanel(featureName, grantedLevel) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !featureName) return;
        const className = String(classInput?.value || "").trim() || "--";
        itemPanelTitle.textContent = featureName;
        itemPanelBody.innerHTML = "";
        const rows = [
          ["Feature", featureName],
          ["Class", className],
          ["Granted Level", `Lv ${grantedLevel}`],
          ["Description", "No detailed description found in datastore."],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", `${label}: ${value}`);
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function syncClassLevelProgressionForCurrentCharacter({ force = false } = {}) {
        const className = String(classInput?.value || "").trim();
        const level = getCurrentCharacterLevel();
        if (!force && className === lastObservedClassForProgression && level === lastObservedLevelForProgression) {
          return;
        }
        lastObservedClassForProgression = className;
        lastObservedLevelForProgression = level;

        currentClassProgressionFeatures = className
          ? getCumulativeClassFeatures(className, level)
          : [];
        renderTraitsList();
        let didTrimKnownSpells = false;

        const cantripCap = getClassCantripCapForCurrentLevel();
        if (Number.isFinite(cantripCap) && cantripItems.length > cantripCap) {
          cantripItems = cantripItems.slice(0, cantripCap);
          renderCantrips();
          didTrimKnownSpells = true;
        }

        const level1Cap = getSpellLearnCapForLevel(1);
        if (spellLevel1Items.length > level1Cap) {
          spellLevel1Items = spellLevel1Items.slice(0, level1Cap);
          renderSpellLevel1();
          didTrimKnownSpells = true;
        }
        const level2Cap = getSpellLearnCapForLevel(2);
        if (spellLevel2Items.length > level2Cap) {
          spellLevel2Items = spellLevel2Items.slice(0, level2Cap);
          renderSpellLevel2();
          didTrimKnownSpells = true;
        }
        const level3Cap = getSpellLearnCapForLevel(3);
        if (spellLevel3Items.length > level3Cap) {
          spellLevel3Items = spellLevel3Items.slice(0, level3Cap);
          renderSpellLevel3();
          didTrimKnownSpells = true;
        }

        const slotCounts = getClassSpellSlotCountsForCurrentLevel();
        renderSpellSlotSquares(slotCounts);
        if (didTrimKnownSpells) {
          scheduleSave();
        }
      }

      function setSavingThrowProficiencies(options = []) {
        const optionSet = new Set(
          options.map((value) => String(value || "").trim().toLowerCase()).filter(Boolean)
        );
        const abilityNames = {
          str: "strength",
          dex: "dexterity",
          con: "constitution",
          int: "intelligence",
          wis: "wisdom",
          cha: "charisma",
        };
        saveRows.forEach((row) => {
          const ability = row.dataset.ability;
          const checkbox = row.querySelector("input[type='checkbox']");
          if (!checkbox) return;
          const name = abilityNames[ability];
          checkbox.checked = name ? optionSet.has(name) : false;
          checkbox.disabled = true;
        });
        recalcDerived();
      }

      function applyClassSelection(entry, { rollHp = false } = {}) {
        if (!entry) return;
        syncSubclassInputForClass(entry);
        updateTotalHpForClass(entry);
        setSavingThrowProficiencies(entry.savingThrows || []);
        currentWeaponProficiencies = Array.isArray(entry.weaponProficiencies)
          ? entry.weaponProficiencies.slice()
          : [];
        if (proficienciesListEl) {
          proficienciesListEl.innerHTML = "";
          const weaponText = (entry.weaponProficiencies || []).join(", ") || "--";
          const armorText = (entry.armorTraining || []).join(", ") || "--";
          const weaponItem = document.createElement("li");
          weaponItem.textContent = `Weapons: ${weaponText}`;
          const armorItem = document.createElement("li");
          armorItem.textContent = `Armor: ${armorText}`;
          proficienciesListEl.appendChild(weaponItem);
          proficienciesListEl.appendChild(armorItem);
        }
        syncClassLevelProgressionForCurrentCharacter({ force: true });
        buildCantripPickerList(spellSearch?.value || "");
      }

      function finalizeClassSelection(entry) {
        if (!entry) return;
        syncSubclassInputForClass(entry);
        if (xpInput) {
          setListValue(xpInput, String(DEFAULT_XP));
        }
        applyClassSelection(entry, { rollHp: true });
        const currentBackgroundName = String(backgroundInput?.value || "").trim();
        const hasBackgroundSelection = Boolean(
          currentBackgroundName && backgroundByName.has(currentBackgroundName)
        );
        requireBackgroundAfterClassEquipment = Boolean(newCharacterSetupFlowActive || !hasBackgroundSelection);
        pendingBackgroundClassEntry = requireBackgroundAfterClassEquipment ? null : pendingBackgroundClassEntry;
        openClassEquipmentPicker(entry);
        scheduleSave();
        openClassPanel(entry);
        if (itemPanel) {
          itemPanel.classList.remove("open");
          itemPanel.setAttribute("aria-hidden", "true");
        }
      }

      function rollDamage(dice, label, ability) {
        const detail = rollDiceDetailed(dice);
        playDiceSound();
        const abilityKey = ability === "finesse"
          ? (toNumber(getListValue(abilityMods.dex)) >= toNumber(getListValue(abilityMods.str)) ? "dex" : "str")
          : ability || "str";
        const modValue = toNumber(getListValue(abilityMods[abilityKey]));
        const total = floorRollTotal(detail.total + modValue);
        resultEl.textContent = `Rolling... (${detail.total})`;
        return setDoc(rollRef, {
          roll: detail.total,
          mod: modValue,
          value: total,
          label,
          parts: [
            { label: dice, value: detail.total, detail: detail.rolls.join("+") },
            { label: `${abilityKey.toUpperCase()} Mod`, value: modValue },
          ],
          by: "anonymous",
          at: serverTimestamp(),
        });
      }

      function renderEquipment() {
        if (!equipmentListEl) return;
        equipmentListEl.innerHTML = "";
        equipmentItems.forEach((item) => {
          const weapon = getWeaponData(item.name);
          const armor = getArmorData(item.name);
          const isArmor = Boolean(armor && !weapon);
          const displayName = weapon?.name || item.name;
          const isWeaponEquipped = item.id === equippedMainId || item.id === equippedOffhandId;
          const isArmorEquipped = isArmor
            ? (armor.isShield ? item.id === equippedShieldId : item.id === equippedArmorId)
            : false;
          const isEquipped = isWeaponEquipped || isArmorEquipped;
          const row = document.createElement("div");
          row.className = "equipment-item";
          if (displayName === activeWeaponName) {
            row.classList.add("active");
          }
          const equipBtn = document.createElement("button");
          equipBtn.type = "button";
          equipBtn.className = "equip-btn";
          if (isEquipped) {
            equipBtn.classList.add("equipped");
          }
          equipBtn.textContent = isEquipped ? "Unequip" : "Equip";
          equipBtn.addEventListener("click", () => {
            if (isArmor) {
              handleArmorEquipToggle(item);
              return;
            }
            handleEquipToggle(item);
          });
          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "equipment-remove";
          removeBtn.setAttribute("aria-label", `Remove ${displayName}`);
          removeBtn.textContent = "X";
          removeBtn.addEventListener("click", () => {
            const wasMain = item.id === equippedMainId;
            const wasOffhand = item.id === equippedOffhandId;
            const wasArmor = item.id === equippedArmorId;
            const wasShield = item.id === equippedShieldId;
            equipmentItems = equipmentItems.filter((entry) => entry.id !== item.id);
            if (wasMain) {
              equippedMainId = "";
              equippedMainTwoHanded = false;
            }
            if (wasOffhand) {
              equippedOffhandId = "";
            }
            if (wasArmor) {
              equippedArmorId = "";
            }
            if (wasShield) {
              equippedShieldId = "";
            }
            if (activeWeaponName === displayName) {
              activeWeaponName = equipmentItems[0]?.name || "";
            }
            setEquipStatus("");
            updateActiveWeaponLabel();
            renderEquipment();
            recalcDerived();
            scheduleSave();
          });
          row.appendChild(removeBtn);
          if (isEquipped) {
            row.appendChild(equipBtn);
          }
          const label = document.createElement("div");
          label.style.cursor = "pointer";
          label.textContent = displayName;
          label.addEventListener("click", () => {
            if (!isArmor) {
              activeWeaponName = displayName;
            }
            updateActiveWeaponLabel();
            renderEquipment();
            openItemPanel(displayName);
          });
          row.appendChild(label);
          if (item.id === equippedMainId || item.id === equippedOffhandId) {
            const badge = document.createElement("span");
            badge.className = "equip-badge";
            badge.textContent = item.id === equippedMainId ? "Main" : "Offhand";
            row.appendChild(badge);
          } else if (isArmor) {
            const badge = document.createElement("span");
            badge.className = "equip-badge";
            badge.textContent = armor.isShield
              ? (item.id === equippedShieldId ? "Shield" : "Shield")
              : (item.id === equippedArmorId ? "Worn" : "Armor");
            row.appendChild(badge);
          }
          if (!isEquipped && !isArmor) {
            row.appendChild(equipBtn);
          } else if (!isEquipped && isArmor) {
            row.appendChild(equipBtn);
          }
          if (!isArmor && isVersatileWeapon(weapon)) {
            const twoHandBtn = document.createElement("button");
            twoHandBtn.type = "button";
            twoHandBtn.className = "twohand-btn";
            const isActive = item.id === equippedMainId && equippedMainTwoHanded;
            if (isActive) {
              twoHandBtn.classList.add("active");
            }
            twoHandBtn.textContent = "Two Hands";
            twoHandBtn.disabled = item.id !== equippedMainId;
            twoHandBtn.addEventListener("click", () => {
              handleTwoHandToggle(item);
            });
            row.appendChild(twoHandBtn);
          }
          equipmentListEl.appendChild(row);
        });
      }

      function updateActiveWeaponLabel() {
        if (!activeWeaponLabel) return;
        const mainItem = equipmentItems.find((item) => item.id === equippedMainId);
        if (mainItem) {
          activeWeaponLabel.textContent = `Equipped: ${mainItem.name}${equippedMainTwoHanded ? " (Two Hands)" : ""}`;
          updateAttackRollLabel();
          return;
        }
        activeWeaponLabel.textContent = activeWeaponName
          ? `Active: ${activeWeaponName}`
          : "No weapon selected";
        updateAttackRollLabel();
      }

      function updateAttackRollLabel() {
        if (!attackRollBtn) return;
        const mainItem = getEquippedWeaponById(equippedMainId);
        const weaponName = mainItem?.name || "";
        const weapon = weaponName ? getWeaponData(weaponName) : null;
        if (!weapon) {
          attackRollBtn.textContent = "Hit";
          attackRollBtn.disabled = true;
          return;
        }
        attackRollBtn.disabled = false;
        const useTwoHands =
          mainItem && mainItem.id === equippedMainId && equippedMainTwoHanded && isVersatileWeapon(weapon);
        const dice = getWeaponDamageDie(weapon, useTwoHands);
        attackRollBtn.textContent = dice ? `Hit (${dice})` : "Hit";
      }

      function setEquipStatus(message = "") {
        if (!equipStatusEl) return;
        equipStatusEl.textContent = message;
      }

      function setPickerOpen(isOpen) {
        if (!weaponPicker) return;
        weaponPicker.classList.toggle("open", isOpen);
        weaponPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (isOpen) {
          pickerSelected = "";
          if (weaponPickerAdd) {
            weaponPickerAdd.disabled = true;
          }
        }
      }

      function setSpellPickerOpen(isOpen) {
        if (!spellPicker) return;
        spellPicker.classList.toggle("open", isOpen);
        spellPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (isOpen) {
          cantripSelected = "";
          if (spellPickerAdd) {
            spellPickerAdd.disabled = true;
          }
        }
      }

      function setFeatPickerOpen(isOpen) {
        if (!featPicker) return;
        featPicker.classList.toggle("open", isOpen);
        featPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (isOpen) {
          featSelected = "";
          if (featPickerAdd) {
            featPickerAdd.disabled = true;
          }
          if (featSearch) {
            featSearch.placeholder = featPromptLevel
              ? `Search feats for level ${featPromptLevel}...`
              : "Search feats...";
          }
        }
      }

      function setFeatChoicePickerOpen(isOpen) {
        if (!featChoicePicker) return;
        featChoicePicker.classList.toggle("open", isOpen);
        featChoicePicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (!isOpen) {
          pendingFeatChoiceContext = null;
          if (featChoiceApply) {
            featChoiceApply.disabled = true;
          }
        }
      }

      function setRacePickerOpen(isOpen) {
        if (!racePicker) return;
        if (!isOpen && racePickerLocked) return;
        const lockedOpen = Boolean(racePickerLocked && isOpen);
        racePicker.classList.toggle("open", isOpen);
        racePicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        racePicker.classList.toggle("locked", lockedOpen);
        document.body.classList.toggle("race-picker-modal-open", lockedOpen);
        if (isOpen) {
          raceSelected = "";
          if (racePickerAdd) {
            racePickerAdd.disabled = true;
          }
        }
      }

      function setClassPickerOpen(isOpen) {
        if (!classPicker) return;
        if (!isOpen && classPickerLocked) return;
        const lockedOpen = Boolean(classPickerLocked && isOpen);
        classPicker.classList.toggle("open", isOpen);
        classPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        classPicker.classList.toggle("locked", lockedOpen);
        document.body.classList.toggle("class-picker-modal-open", lockedOpen);
        if (isOpen) {
          classSelected = "";
          if (classPickerAdd) {
            classPickerAdd.disabled = true;
          }
        }
      }

      function setClassEquipmentOpen(isOpen) {
        if (!classEquipmentPicker) return;
        classEquipmentPicker.classList.toggle("open", isOpen);
        classEquipmentPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (!isOpen) {
          pendingClassEquipmentEntry = null;
        }
      }

      function setBackgroundPickerOpen(isOpen) {
        if (!backgroundPicker) return;
        if (!isOpen && backgroundPickerLocked) return;
        const lockedOpen = Boolean(backgroundPickerLocked && isOpen);
        backgroundPicker.classList.toggle("open", isOpen);
        backgroundPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        backgroundPicker.classList.toggle("locked", lockedOpen);
        document.body.classList.toggle("background-picker-modal-open", lockedOpen);
        if (isOpen) {
          backgroundSelected = "";
          if (backgroundPickerAdd) {
            backgroundPickerAdd.disabled = true;
          }
        }
      }

      function setBackgroundConfigOpen(isOpen) {
        if (!backgroundConfigPicker) return;
        if (!isOpen && backgroundConfigLocked) return;
        const lockedOpen = Boolean(backgroundConfigLocked && isOpen);
        backgroundConfigPicker.classList.toggle("open", isOpen);
        backgroundConfigPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        backgroundConfigPicker.classList.toggle("locked", lockedOpen);
        document.body.classList.toggle("background-config-modal-open", lockedOpen);
        if (!isOpen) {
          pendingBackgroundEntry = null;
        }
      }

      function setItemPickerOpen(isOpen) {
        if (!itemPicker) return;
        itemPicker.classList.toggle("open", isOpen);
        itemPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (isOpen) {
          itemSelected = "";
          if (itemPickerAdd) {
            itemPickerAdd.disabled = true;
          }
        }
      }

      function createEquipmentItem(name) {
        return {
          id: `w_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
          name,
        };
      }

      function normalizeEquipmentItems(items) {
        if (!Array.isArray(items)) return [];
        if (items.length === 0) return [];
        if (typeof items[0] === "string") {
          return items.map((name) => createEquipmentItem(name));
        }
        return items.map((item) => ({
          id: item.id || createEquipmentItem(item.name || "Weapon").id,
          name: item.name || "Weapon",
        }));
      }

      function getEquippedWeaponById(id) {
        return equipmentItems.find((item) => item.id === id) || null;
      }

      function getEquippedArmorById(id) {
        if (!id) return null;
        const item = equipmentItems.find((entry) => entry.id === id);
        if (!item) return null;
        const armor = getArmorData(item.name);
        return armor ? { item, armor } : null;
      }

      function handleArmorEquipToggle(item) {
        const armor = getArmorData(item.name);
        if (!armor) return;
        if (armor.isShield) {
          if (item.id === equippedShieldId) {
            equippedShieldId = "";
            renderEquipment();
            recalcDerived();
            scheduleSave();
            return;
          }
          if (equippedMainTwoHanded) {
            setEquipStatus("You can't equip a shield while using two hands.");
            return;
          }
          if (equippedOffhandId) {
            setEquipStatus("Unequip offhand weapon before equipping a shield.");
            return;
          }
          equippedShieldId = item.id;
          renderEquipment();
          recalcDerived();
          scheduleSave();
          return;
        }

        if (item.id === equippedArmorId) {
          equippedArmorId = "";
          renderEquipment();
          recalcDerived();
          scheduleSave();
          return;
        }
        equippedArmorId = item.id;
        renderEquipment();
        recalcDerived();
        scheduleSave();
      }

      function handleEquipToggle(item) {
        const weapon = getWeaponData(item.name);
        if (!weapon) return;
        const isTwoHanded = weapon.properties.includes("Two-Handed");
        const isEquippedMain = item.id === equippedMainId;
        const isEquippedOff = item.id === equippedOffhandId;

        if (isEquippedMain || isEquippedOff) {
          if (isEquippedMain) {
            equippedMainId = "";
            equippedMainTwoHanded = false;
          } else {
            equippedOffhandId = "";
          }
          setEquipStatus("");
          renderEquipment();
          updateActiveWeaponLabel();
          scheduleSave();
          return;
        }

        if (isTwoHanded) {
          if (equippedMainId || equippedOffhandId || equippedShieldId) {
            setEquipStatus("Two-handed weapons require both hands.");
            return;
          }
          equippedMainId = item.id;
          equippedOffhandId = "";
          equippedMainTwoHanded = true;
          activeWeaponName = item.name;
          setEquipStatus("");
          renderEquipment();
          updateActiveWeaponLabel();
          scheduleSave();
          return;
        }

        if (!equippedMainId) {
          equippedMainId = item.id;
          equippedMainTwoHanded = false;
          activeWeaponName = item.name;
          setEquipStatus("");
          renderEquipment();
          updateActiveWeaponLabel();
          scheduleSave();
          return;
        }

        if (equippedMainTwoHanded) {
          setEquipStatus("You can't equip another weapon while using two hands.");
          return;
        }
        if (equippedShieldId) {
          setEquipStatus("Unequip shield before equipping an offhand weapon.");
          return;
        }

        const mainWeapon = getEquippedWeaponById(equippedMainId);
        const mainWeaponData = mainWeapon ? getWeaponData(mainWeapon.name) : null;
        const mainTwoHanded = mainWeaponData?.properties.includes("Two-Handed");
        if (mainTwoHanded) {
          setEquipStatus("You can't equip an offhand weapon while a two-handed weapon is equipped.");
          return;
        }

        if (!equippedOffhandId) {
          const mainIsLight = mainWeaponData?.properties.includes("Light");
          const offIsLight = weapon.properties.includes("Light");
          if (!mainIsLight || !offIsLight) {
            setEquipStatus("Offhand requires a Light weapon (unless you have a feature).");
            return;
          }
          equippedOffhandId = item.id;
          setEquipStatus("");
          renderEquipment();
          updateActiveWeaponLabel();
          scheduleSave();
          return;
        }

        setEquipStatus("You already have two weapons equipped.");
      }

      function handleTwoHandToggle(item) {
        if (item.id !== equippedMainId) {
          setEquipStatus("Two Hands only applies to the equipped main weapon.");
          return;
        }
        const weapon = getWeaponData(item.name);
        if (!weapon || !isVersatileWeapon(weapon)) return;
        if (equippedOffhandId) {
          setEquipStatus("You can't use two hands while an offhand weapon is equipped.");
          return;
        }
        if (equippedShieldId) {
          setEquipStatus("You can't use two hands while a shield is equipped.");
          return;
        }
        equippedMainTwoHanded = !equippedMainTwoHanded;
        setEquipStatus("");
        renderEquipment();
        updateActiveWeaponLabel();
        scheduleSave();
      }

      function buildWeaponPickerList(filterText = "") {
        if (!weaponPickerList) return;
        const filter = filterText.trim().toLowerCase();
        weaponPickerList.innerHTML = "";

        if (!weaponsLoaded || !armorsLoaded) {
          const loading = document.createElement("div");
          loading.className = "weapon-option";
          loading.textContent = "Loading equipment...";
          weaponPickerList.appendChild(loading);
          return;
        }
        if (!weaponTable.length && !armorTable.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No equipment found.";
          weaponPickerList.appendChild(empty);
          return;
        }

        const categoryOrder = [
          "Armor",
          "Simple Melee Weapons",
          "Simple Ranged Weapons",
          "Martial Melee Weapons",
          "Martial Ranged Weapons",
        ];

        const matchesFilter = (weapon) =>
          weapon.name.toLowerCase().includes(filter);

        const grouped = new Map();
        weaponTable.forEach((weapon) => {
          if (!matchesFilter(weapon)) return;
          const category = weapon.category || "Other";
          if (!grouped.has(category)) grouped.set(category, []);
          grouped.get(category).push(weapon);
        });
        armorTable.forEach((armor) => {
          if (!matchesFilter(armor)) return;
          const category = "Armor";
          if (!grouped.has(category)) grouped.set(category, []);
          grouped.get(category).push(armor);
        });

        const renderGroup = (category, entries) => {
          if (!entries.length) return;
          const header = document.createElement("div");
          header.className = "weapon-category";
          header.textContent = category;
          weaponPickerList.appendChild(header);

          const list = document.createElement("div");
          list.className = "weapon-list";
          entries
            .sort((a, b) => a.name.localeCompare(b.name))
            .forEach((entry) => {
              const option = document.createElement("div");
              option.className = "weapon-option";
              if (entry.name === pickerSelected) {
                option.classList.add("selected");
              }
              option.addEventListener("click", () => {
                pickerSelected = entry.name;
                if (weaponPickerAdd) {
                  weaponPickerAdd.disabled = false;
                }
                buildWeaponPickerList(weaponSearch?.value || "");
              });
              const name = document.createElement("strong");
              name.textContent = entry.name;
              const meta = document.createElement("span");
              if (category === "Armor") {
                const dexPart =
                  entry.dexBonus?.allowed
                    ? entry.dexBonus?.max === null
                      ? " + DEX"
                      : ` + DEX (max ${entry.dexBonus.max})`
                    : "";
                const cost = entry.costGp !== null && entry.costGp !== undefined ? `${entry.costGp} gp` : "--";
                meta.textContent = `AC ${entry.baseAC}${dexPart}  ${entry.type || "armor"}  ${cost}`;
              } else {
                const cost = entry.cost || "--";
                meta.textContent = `${entry.damage}  ${entry.properties === "" ? "No properties" : entry.properties}  ${cost}`;
              }
              option.appendChild(name);
              option.appendChild(meta);
              list.appendChild(option);
            });

          weaponPickerList.appendChild(list);
        };

        let rendered = false;
        categoryOrder.forEach((category) => {
          const weapons = grouped.get(category) || [];
          if (weapons.length) {
            renderGroup(category, weapons);
            rendered = true;
            grouped.delete(category);
          }
        });

        const remainingCategories = Array.from(grouped.keys()).sort((a, b) =>
          a.localeCompare(b)
        );
        remainingCategories.forEach((category) => {
          renderGroup(category, grouped.get(category) || []);
          rendered = true;
        });

        if (!rendered) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No equipment matches your search.";
          weaponPickerList.appendChild(empty);
        }
      }

      function getActiveSpellTabLevel() {
        const checked = spellTabInputs.find((input) => input.checked);
        if (!checked) return 0;
        const match = String(checked.id || "").match(/spell-tab-(\d+)/);
        if (!match) return 0;
        const tabIndex = Number(match[1]);
        if (!Number.isFinite(tabIndex) || tabIndex < 1) return 0;
        return tabIndex - 1;
      }

      function getSpellDataForLevel(level) {
        if (level > 3) {
          return {
            loaded: true,
            table: [],
            emptyMessage: `No spell list configured for level ${level}.`,
            loadingMessage: `Loading level ${level} spells...`,
            noMatchMessage: `No level ${level} spells match your search.`,
          };
        }
        if (level === 1) {
          return {
            loaded: spellLevel1Loaded,
            table: spellLevel1Table,
            emptyMessage: "No level 1 spells found.",
            loadingMessage: "Loading level 1 spells...",
            noMatchMessage: "No level 1 spells match your search.",
          };
        }
        if (level === 2) {
          return {
            loaded: spellLevel2Loaded,
            table: spellLevel2Table,
            emptyMessage: "No level 2 spells found.",
            loadingMessage: "Loading level 2 spells...",
            noMatchMessage: "No level 2 spells match your search.",
          };
        }
        if (level === 3) {
          return {
            loaded: spellLevel3Loaded,
            table: spellLevel3Table,
            emptyMessage: "No level 3 spells found.",
            loadingMessage: "Loading level 3 spells...",
            noMatchMessage: "No level 3 spells match your search.",
          };
        }
        return {
          loaded: cantripsLoaded,
          table: cantripTable,
          emptyMessage: "No cantrips found.",
          loadingMessage: "Loading cantrips...",
          noMatchMessage: "No cantrips match your search.",
        };
      }

      function buildCantripPickerList(filterText = "") {
        if (!spellPickerList) return;
        const filter = filterText.trim().toLowerCase();
        const level = getActiveSpellTabLevel();
        const spellData = getSpellDataForLevel(level);
        const learnCap = getSpellLearnCapForLevel(level);
        const learnedCount = getLearnedSpellCountForLevel(level);
        const canLearnMore = learnedCount < learnCap;
        spellPickerList.innerHTML = "";

        if (!spellData.loaded) {
          const loading = document.createElement("div");
          loading.className = "weapon-option";
          loading.textContent = spellData.loadingMessage;
          spellPickerList.appendChild(loading);
          return;
        }

        if (!spellData.table.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = spellData.emptyMessage;
          spellPickerList.appendChild(empty);
          return;
        }

        if (learnCap <= 0) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = level === 0
            ? "No cantrips available for this class at the current level."
            : `No level ${level} spell slots available at the current class level.`;
          spellPickerList.appendChild(empty);
          return;
        }

        if (!canLearnMore) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = level === 0
            ? `Cantrip learn cap reached (${learnedCount}/${learnCap}).`
            : `Level ${level} spell learn cap reached (${learnedCount}/${learnCap}).`;
          spellPickerList.appendChild(empty);
          return;
        }

        const filtered = spellData.table.filter((spell) => {
          if (!cantripAllowedForCharacter(spell)) return false;
          if (!filter) return true;
          const nameMatch = spell.name.toLowerCase().includes(filter);
          const schoolMatch = spell.school.toLowerCase().includes(filter);
          return nameMatch || schoolMatch;
        });

        const grouped = new Map();
        filtered.forEach((spell) => {
          const school = spell.school || "Other";
          if (!grouped.has(school)) grouped.set(school, []);
          grouped.get(school).push(spell);
        });

        const schools = Array.from(grouped.keys()).sort((a, b) => a.localeCompare(b));
        let rendered = false;

        schools.forEach((school) => {
          const spells = grouped.get(school) || [];
          if (!spells.length) return;
          const header = document.createElement("div");
          header.className = "weapon-category";
          header.textContent = school;
          spellPickerList.appendChild(header);

          const list = document.createElement("div");
          list.className = "weapon-list";
          spells
            .slice()
            .sort((a, b) => a.name.localeCompare(b.name))
            .forEach((spell) => {
              const option = document.createElement("div");
              option.className = "weapon-option";
              if (spell.name === cantripSelected) {
                option.classList.add("selected");
              }
              option.addEventListener("click", () => {
                cantripSelected = spell.name;
                if (spellPickerAdd) {
                  spellPickerAdd.disabled = !cantripSelected || !canLearnAnotherSpellAtLevel(getActiveSpellTabLevel());
                }
                openSpellPanel(spell);
                buildCantripPickerList(spellSearch?.value || "");
              });
              const name = document.createElement("strong");
              name.textContent = spell.name;
              const meta = document.createElement("span");
              const metaParts = [spell.school, spell.range].filter(Boolean);
              meta.textContent = metaParts.join("  ") || "No details";
              option.appendChild(name);
              option.appendChild(meta);
              list.appendChild(option);
            });

          spellPickerList.appendChild(list);
          rendered = true;
        });

        if (!rendered) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = spellData.noMatchMessage;
          spellPickerList.appendChild(empty);
        }
      }

      function maybePromptFeatForLevel(level) {
        const milestoneLevel = getFeatMilestoneLevel(level);
        if (!milestoneLevel) return;
        if (featSelectionsByLevel[String(milestoneLevel)]) return;
        featPromptLevel = milestoneLevel;
        setFeatPickerOpen(true);
        buildFeatPickerList(featSearch?.value || "");
      }

      function getFeatChoiceRequirements(feat) {
        if (!feat || typeof feat !== "object") return [];
        const modifiers = feat.modifiers && typeof feat.modifiers === "object" ? feat.modifiers : {};
        const choices = [];
        const allSkills = getAllSkillNames();
        const expandChoiceOptions = (from = []) => {
          const expanded = [];
          const pushUnique = (value) => {
            const text = String(value || "").trim();
            if (!text) return;
            if (!expanded.includes(text)) expanded.push(text);
          };
          from.forEach((entry) => {
            const value = String(entry || "").trim();
            const lower = value.toLowerCase();
            if (!value) return;
            if (lower === "any_skill" || lower === "anyskill") {
              allSkills.forEach(pushUnique);
              return;
            }
            if (lower === "any_proficient_skill") {
              const proficient = skillRows
                .map((row) => row.querySelector("input[type='checkbox']"))
                .filter((box) => box?.checked)
                .map((box) => String(box.id).replace(/^skill-/, "").replace(/-prof$/, "").replace(/-/g, " "))
                .filter(Boolean);
              (proficient.length ? proficient : allSkills).forEach(pushUnique);
              return;
            }
            if (lower === "anytool" || lower === "any_tool" || lower === "anymusicalinstrument" || lower === "any_musical_instrument") {
              return;
            }
            pushUnique(value);
          });
          return expanded;
        };
        const pushChoice = (key, label, from = [], count = 1) => {
          const options = Array.isArray(from) ? expandChoiceOptions(from) : [];
          const pickCount = Math.max(1, Number(count) || 1);
          if (!options.length) return;
          choices.push({ key, label, from: options, count: pickCount });
        };
        pushChoice("ability_score_choice", "Ability score", modifiers.ability_score_choice, modifiers.ability_score_choice_count || 1);
        pushChoice("skill_proficiency_choice", "Skill proficiency", modifiers.skill_proficiency_choice?.from, modifiers.skill_proficiency_choice?.count || 1);
        pushChoice("skill_proficiency_or_expertise_choice", "Skill proficiency or expertise", modifiers.skill_proficiency_or_expertise_choice?.from, modifiers.skill_proficiency_or_expertise_choice?.count || 1);
        pushChoice("tool_proficiency_choice", "Tool proficiency", modifiers.tool_proficiency_choice?.from, modifiers.tool_proficiency_choice?.count || 1);
        pushChoice("skill_tool_choice", "Skill or tool proficiency", modifiers.skill_tool_choice?.from, modifiers.skill_tool_choice?.count || 1);
        pushChoice("expertise_choice", "Expertise", modifiers.expertise_choice?.from, modifiers.expertise_choice?.count || 1);
        pushChoice("damage_resistance_choice", "Damage resistance", modifiers.damage_resistance_choice?.from, modifiers.damage_resistance_choice?.count || 1);
        return choices;
      }

      function getFeatChoiceSummary(level) {
        const levelKey = String(level);
        const selected = featChoiceSelectionsByLevel[levelKey];
        if (!selected || typeof selected !== "object") return "";
        const parts = Object.values(selected)
          .filter((values) => Array.isArray(values) && values.length)
          .map((values) => values.map((value) => toDisplayName(value)).join(", "))
          .filter(Boolean);
        return parts.join(" | ");
      }

      function updateFeatChoiceApplyEnabled() {
        if (!featChoiceApply) return;
        const context = pendingFeatChoiceContext;
        if (!context || !Array.isArray(context.requirements)) {
          featChoiceApply.disabled = true;
          return;
        }
        const complete = context.requirements.every((requirement) => {
          const values = Array.isArray(context.selections?.[requirement.key]) ? context.selections[requirement.key] : [];
          if (values.length !== requirement.count) return false;
          if (values.some((entry) => !entry)) return false;
          return new Set(values).size === values.length;
        });
        featChoiceApply.disabled = !complete;
      }

      function buildFeatChoicePicker() {
        if (!featChoiceBody) return;
        featChoiceBody.innerHTML = "";
        const context = pendingFeatChoiceContext;
        if (!context || !Array.isArray(context.requirements) || !context.requirements.length) {
          updateFeatChoiceApplyEnabled();
          return;
        }

        context.requirements.forEach((requirement) => {
          const section = document.createElement("div");
          section.className = "weapon-option";
          const title = document.createElement("strong");
          title.textContent = `${requirement.label} (${requirement.count})`;
          section.appendChild(title);

          for (let i = 0; i < requirement.count; i += 1) {
            const select = document.createElement("select");
            select.style.marginTop = "6px";
            select.dataset.choiceKey = requirement.key;
            select.dataset.choiceIndex = String(i);

            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = `Select ${requirement.label.toLowerCase()}...`;
            select.appendChild(placeholder);

            requirement.from.forEach((optionValue) => {
              const option = document.createElement("option");
              option.value = optionValue;
              option.textContent = toDisplayName(optionValue);
              select.appendChild(option);
            });

            const currentValues = Array.isArray(context.selections?.[requirement.key])
              ? context.selections[requirement.key]
              : [];
            if (currentValues[i]) {
              select.value = currentValues[i];
            }

            select.addEventListener("change", () => {
              const key = select.dataset.choiceKey || "";
              const index = Number(select.dataset.choiceIndex || "0");
              if (!context.selections[key]) {
                context.selections[key] = Array(requirement.count).fill("");
              }
              context.selections[key][index] = select.value;
              updateFeatChoiceApplyEnabled();
            });
            section.appendChild(select);
          }

          featChoiceBody.appendChild(section);
        });

        updateFeatChoiceApplyEnabled();
      }

      function commitFeatSelection(featName, level, choiceSelections = {}) {
        const milestoneLevel = getFeatMilestoneLevel(level);
        if (!featName || !milestoneLevel) return;
        const levelKey = String(milestoneLevel);
        featSelectionsByLevel[levelKey] = featName;
        featChoiceSelectionsByLevel[levelKey] = choiceSelections && typeof choiceSelections === "object"
          ? Object.fromEntries(
              Object.entries(choiceSelections)
                .map(([key, values]) => [
                  key,
                  Array.isArray(values)
                    ? values.map((entry) => String(entry || "").trim()).filter(Boolean)
                    : [],
                ])
                .filter(([, values]) => values.length)
            )
          : {};
        recomputeFeatAbilityBonuses();
        rebuildSelectedFeatItems();
        renderTraitsList();
        updateAllSkillProficiencies();
        recalcDerived();
        buildCantripPickerList(spellSearch?.value || "");
        scheduleSave();
      }

      function applyFeatSelection(featName, level = featPromptLevel) {
        const milestoneLevel = getFeatMilestoneLevel(level);
        if (!featName || !milestoneLevel) return;
        const feat = getFeatData(featName);
        const requirements = getFeatChoiceRequirements(feat);
        if (!requirements.length) {
          commitFeatSelection(featName, milestoneLevel, {});
          return;
        }
        const levelKey = String(milestoneLevel);
        const previous = featChoiceSelectionsByLevel[levelKey] || {};
        const seeded = {};
        requirements.forEach((requirement) => {
          const prevValues = Array.isArray(previous[requirement.key]) ? previous[requirement.key] : [];
          seeded[requirement.key] = Array.from({ length: requirement.count }, (_, idx) => prevValues[idx] || "");
        });
        pendingFeatChoiceContext = {
          level: milestoneLevel,
          featName,
          requirements,
          selections: seeded,
        };
        buildFeatChoicePicker();
        setFeatChoicePickerOpen(true);
      }

      function buildFeatPickerList(filterText = "") {
        if (!featPickerList) return;
        const filter = filterText.trim().toLowerCase();
        featPickerList.innerHTML = "";

        if (!featsLoaded) {
          const loading = document.createElement("div");
          loading.className = "weapon-option";
          loading.textContent = "Loading feats...";
          featPickerList.appendChild(loading);
          return;
        }

        if (!featTable.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No feats found.";
          featPickerList.appendChild(empty);
          return;
        }

        const filtered = featTable.filter((entry) => {
          if (!filter) return true;
          const nameMatch = entry.name.toLowerCase().includes(filter);
          const descriptionMatch = String(entry.description || "").toLowerCase().includes(filter);
          return nameMatch || descriptionMatch;
        });

        if (!filtered.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No feats match your search.";
          featPickerList.appendChild(empty);
          return;
        }

        const list = document.createElement("div");
        list.className = "weapon-list";
        filtered
          .slice()
          .sort((a, b) => a.name.localeCompare(b.name))
          .forEach((entry) => {
            const option = document.createElement("div");
            option.className = "weapon-option";
            if (entry.name === featSelected) {
              option.classList.add("selected");
            }
            option.addEventListener("click", () => {
              featSelected = entry.name;
              if (featPickerAdd) {
                featPickerAdd.disabled = false;
              }
              openFeatPanel(entry.name);
              buildFeatPickerList(featSearch?.value || "");
            });
            const name = document.createElement("strong");
            name.textContent = entry.name;
            const meta = document.createElement("span");
            meta.textContent = entry.source || entry.description || "No description";
            option.appendChild(name);
            option.appendChild(meta);
            list.appendChild(option);
          });
        featPickerList.appendChild(list);
      }

      function buildRacePickerList(filterText = "") {
        if (!racePickerList) return;
        const filter = filterText.trim().toLowerCase();
        racePickerList.innerHTML = "";

        if (!racesLoaded) {
          const loading = document.createElement("div");
          loading.className = "weapon-option";
          loading.textContent = "Loading races...";
          racePickerList.appendChild(loading);
          return;
        }

        if (!raceTable.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No races found.";
          racePickerList.appendChild(empty);
          return;
        }

        const races = raceList
          .filter((race) => race.toLowerCase().includes(filter))
          .sort((a, b) => a.localeCompare(b));

        if (!races.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No races match your search.";
          racePickerList.appendChild(empty);
          return;
        }

        const list = document.createElement("div");
        list.className = "weapon-list";
        races.forEach((race) => {
          const entry = raceByName.get(race);
          const option = document.createElement("div");
          option.className = "weapon-option";
          if (race === raceSelected) {
            option.classList.add("selected");
          }
          option.addEventListener("click", () => {
            raceSelected = race;
            if (racePickerAdd) {
              racePickerAdd.disabled = false;
            }
            if (entry) {
              openRacePanel(entry);
            }
            buildRacePickerList(raceSearch?.value || "");
          });
          const name = document.createElement("strong");
          name.textContent = race;
          option.appendChild(name);
          list.appendChild(option);
        });

        racePickerList.appendChild(list);
      }

      function buildClassPickerList(filterText = "") {
        if (!classPickerList) return;
        const filter = filterText.trim().toLowerCase();
        classPickerList.innerHTML = "";

        if (!classesLoaded) {
          const loading = document.createElement("div");
          loading.className = "weapon-option";
          loading.textContent = "Loading classes...";
          classPickerList.appendChild(loading);
          return;
        }

        if (!classTable.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No classes found.";
          classPickerList.appendChild(empty);
          return;
        }

        const filtered = classTable.filter((entry) => {
          if (!filter) return true;
          const nameMatch = entry.name.toLowerCase().includes(filter);
          const descMatch = entry.description.toLowerCase().includes(filter);
          return nameMatch || descMatch;
        });

        const list = document.createElement("div");
        list.className = "weapon-list";
        filtered
          .slice()
          .sort((a, b) => a.name.localeCompare(b.name))
          .forEach((entry) => {
            const option = document.createElement("div");
            option.className = "weapon-option";
            if (entry.name === classSelected) {
              option.classList.add("selected");
            }
            option.addEventListener("click", () => {
              classSelected = entry.name;
              if (classPickerAdd) {
                classPickerAdd.disabled = false;
              }
              commitClassPickerSelection(entry.name);
            });
            const name = document.createElement("strong");
            name.textContent = entry.name;
            const meta = document.createElement("span");
            meta.textContent = entry.description || "No description";
            option.appendChild(name);
            option.appendChild(meta);
            list.appendChild(option);
          });

        if (!filtered.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No classes match your search.";
          classPickerList.appendChild(empty);
          return;
        }

        classPickerList.appendChild(list);
      }

      function buildClassEquipmentPicker(entry) {
        if (!classEquipmentBody || !entry) return;
        classEquipmentBody.innerHTML = "";
        const rows = Array.isArray(entry.startingEquipment) ? entry.startingEquipment : [];
        if (!rows.length) {
          const empty = document.createElement("div");
          empty.className = "spell-meta";
          empty.textContent = "No starting equipment listed for this class.";
          classEquipmentBody.appendChild(empty);
          return;
        }
        pendingClassEquipmentSelections = rows.map((line, idx) => {
          const parsed = parseClassEquipmentLine(line);
          if (parsed.type !== "choice") {
            return { type: "fixed", value: parsed.value };
          }
          const prev = pendingClassEquipmentSelections[idx];
          const selected = Number.isFinite(Number(prev?.selected))
            ? Math.max(0, Math.min(Number(prev.selected), parsed.options.length - 1))
            : 0;
          return { type: "choice", options: parsed.options.slice(), selected };
        });

        pendingClassEquipmentSelections.forEach((selection, idx) => {
          const card = document.createElement("div");
          card.className = "class-equipment-row";
          const title = document.createElement("h4");
          title.textContent = `Choice ${idx + 1}`;
          card.appendChild(title);
          const subChoiceWrap = document.createElement("div");
          const renderWeaponSubChoice = (text) => {
            subChoiceWrap.innerHTML = "";
            const requirement = getClassEquipmentWeaponRequirementFromText(text);
            if (!requirement) {
              updateClassEquipmentApplyState();
              return;
            }
            const label = document.createElement("div");
            label.className = "spell-meta";
            label.textContent = getClassEquipmentWeaponRequirementLabel(requirement);
            subChoiceWrap.appendChild(label);
            const candidates = getClassEquipmentWeaponCandidates(requirement);
            const selectedPicks = getSelectionWeaponPicks(selection, requirement.qty);
            for (let pickIdx = 0; pickIdx < requirement.qty; pickIdx += 1) {
              const pick = document.createElement("select");
              pick.style.marginTop = pickIdx === 0 ? "6px" : "4px";
              const first = document.createElement("option");
              first.value = "";
              first.textContent = requirement.qty > 1
                ? `Select weapon ${pickIdx + 1}`
                : "Select a weapon";
              pick.appendChild(first);
              candidates.forEach((name) => {
                const option = document.createElement("option");
                option.value = name;
                option.textContent = name;
                pick.appendChild(option);
              });
              const selectedPick = selectedPicks[pickIdx];
              if (selectedPick && candidates.includes(selectedPick)) {
                pick.value = selectedPick;
              }
              pick.addEventListener("change", () => {
                const nextPicks = getSelectionWeaponPicks(selection, requirement.qty);
                nextPicks[pickIdx] = String(pick.value || "").trim();
                if (selection.type === "choice") {
                  if (!selection.weaponPicksByOption || typeof selection.weaponPicksByOption !== "object") {
                    selection.weaponPicksByOption = {};
                  }
                  selection.weaponPicksByOption[selection.selected] = nextPicks;
                } else {
                  selection.weaponPicks = nextPicks;
                  selection.weaponPick = nextPicks[0] || "";
                }
                updateClassEquipmentApplyState();
              });
              subChoiceWrap.appendChild(pick);
            }
            if (selection.type === "choice") {
              if (!selection.weaponPicksByOption || typeof selection.weaponPicksByOption !== "object") {
                selection.weaponPicksByOption = {};
              }
              if (!Array.isArray(selection.weaponPicksByOption[selection.selected])) {
                selection.weaponPicksByOption[selection.selected] = selectedPicks;
              }
            } else if (!Array.isArray(selection.weaponPicks)) {
              selection.weaponPicks = selectedPicks;
              selection.weaponPick = selectedPicks[0] || "";
            }
            updateClassEquipmentApplyState();
          };
          if (selection.type === "fixed") {
            const text = document.createElement("div");
            const fixedText = selection.value || "--";
            text.textContent = fixedText;
            card.appendChild(text);
            renderWeaponSubChoice(fixedText);
          } else {
            const select = document.createElement("select");
            selection.options.forEach((optionText, optIdx) => {
              const option = document.createElement("option");
              option.value = String(optIdx);
              option.textContent = optionText;
              if (optIdx === selection.selected) option.selected = true;
              select.appendChild(option);
            });
            select.addEventListener("change", () => {
              selection.selected = Math.max(0, Number(select.value) || 0);
              renderWeaponSubChoice(selection.options[selection.selected] || selection.options[0] || "");
              updateClassEquipmentApplyState();
            });
            card.appendChild(select);
            renderWeaponSubChoice(selection.options[selection.selected] || selection.options[0] || "");
          }
          card.appendChild(subChoiceWrap);
          classEquipmentBody.appendChild(card);
        });
        updateClassEquipmentApplyState();
      }

      function applyClassStartingEquipment(entry) {
        if (!entry) return;
        revertClassStartingEquipmentEffects();
        const inventoryAdds = [];
        const equipmentAdds = [];
        pendingClassEquipmentSelections.forEach((selection) => {
          const text =
            selection.type === "choice"
              ? selection.options[selection.selected] || selection.options[0] || ""
              : selection.value;
          splitClassEquipmentTextToEntries(text).forEach((rawPiece) => {
            const requirement = parseClassEquipmentWeaponRequirement(rawPiece);
            if (requirement) {
              const chosenWeapons = getSelectionWeaponPicks(selection, requirement.qty).filter(Boolean);
              if (chosenWeapons.length < requirement.qty) return;
              for (let count = 0; count < requirement.qty; count += 1) {
                const chosenWeapon = chosenWeapons[count] || chosenWeapons[0];
                if (!chosenWeapon) continue;
                const eq = createEquipmentItem(chosenWeapon);
                equipmentItems.push(eq);
                equipmentAdds.push(eq.id);
              }
              return;
            }
            const normalized = normalizeClassEquipmentEntry(rawPiece);
            if (!normalized.name) return;
            const resolved = resolveCatalogItem(normalized.name);
            const resolvedName = resolved.name || normalized.name;
            const qty = Math.max(1, Number(normalized.qty) || 1);
            const isWeapon = Boolean(resolved.isWeapon);
            const isArmorOrShield = Boolean(resolved.isArmor);
            for (let idx = 0; idx < qty; idx += 1) {
              if (!isWeapon && !isArmorOrShield) {
                inventoryItems.push(resolvedName);
                inventoryAdds.push(resolvedName);
              }
              if (isWeapon || isArmorOrShield) {
                const eq = createEquipmentItem(resolvedName);
                equipmentItems.push(eq);
                equipmentAdds.push(eq.id);
              }
            }
          });
        });
        appliedClassInventoryNames = inventoryAdds;
        appliedClassEquipmentIds = equipmentAdds;
        appliedClassEquipmentName = entry.name || "";
        renderInventoryItems();
        renderEquipment();
        recalcDerived();
      }

      function openClassEquipmentPicker(entry) {
        pendingClassEquipmentEntry = entry;
        pendingClassEquipmentSelections = [];
        buildClassEquipmentPicker(entry);
        updateClassEquipmentApplyState();
        setClassEquipmentOpen(true);
      }

      function commitClassPickerSelection(selectedName = "") {
        if (!classInput) return;
        const fallbackInput = String(classInput.value || "").trim();
        const chosen = String(selectedName || classSelected || fallbackInput).trim();
        if (!chosen) return;
        const entry = classByName.get(chosen);
        if (!entry) return;
        const shouldRequireSubclass = classPickerLocked;
        classSelected = chosen;
        classInput.value = chosen;
        classPickerLocked = false;
        setClassPickerOpen(false);
        const subclassNames = getClassSubclassNames(entry);
        if (subclassNames.length && shouldRequireSubclass) {
          openAlignmentPicker(entry, { required: false, finalizeOnPick: false });
        }
        finalizeClassSelection(entry);
      }

      function buildBackgroundPickerList(filterText = "") {
        if (!backgroundPickerList) return;
        const filter = filterText.trim().toLowerCase();
        backgroundPickerList.innerHTML = "";

        if (!backgroundsLoaded) {
          const loading = document.createElement("div");
          loading.className = "weapon-option";
          loading.textContent = "Loading backgrounds...";
          backgroundPickerList.appendChild(loading);
          return;
        }

        if (!backgroundList.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No backgrounds found.";
          backgroundPickerList.appendChild(empty);
          return;
        }

        const filtered = backgroundList
          .filter((name) => !filter || name.toLowerCase().includes(filter))
          .sort((a, b) => a.localeCompare(b));

        if (!filtered.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No backgrounds match your search.";
          backgroundPickerList.appendChild(empty);
          return;
        }

        const list = document.createElement("div");
        list.className = "weapon-list";
        filtered.forEach((name) => {
          const entry = backgroundByName.get(name);
          const option = document.createElement("div");
          option.className = "weapon-option";
          if (name === backgroundSelected) {
            option.classList.add("selected");
          }
          option.addEventListener("click", () => {
            backgroundSelected = name;
            if (backgroundPickerAdd) backgroundPickerAdd.disabled = false;
            if (entry) openBackgroundPanel(entry);
            buildBackgroundPickerList(backgroundSearch?.value || "");
          });
          const strong = document.createElement("strong");
          strong.textContent = name;
          const skills = extractBackgroundSkillNames(entry);
          const meta = document.createElement("span");
          meta.textContent = skills.length
            ? `Skills: ${skills.join(", ")}`
            : "No skill data";
          option.appendChild(strong);
          option.appendChild(meta);
          list.appendChild(option);
        });
        backgroundPickerList.appendChild(list);
      }

      function buildBackgroundConfigPanel(entry) {
        if (!backgroundConfigBody || !entry) return;
        backgroundConfigBody.innerHTML = "";

        const abilitySection = document.createElement("div");
        abilitySection.className = "background-config-section";
        const abilityTitle = document.createElement("h4");
        abilityTitle.textContent = "Ability Score Increase";
        abilitySection.appendChild(abilityTitle);

        const modes = getBackgroundAbilityModes(entry);
        if (!modes.length) {
          const text = document.createElement("div");
          text.className = "spell-meta";
          text.textContent = "No ability choices.";
          abilitySection.appendChild(text);
        } else {
          pendingBackgroundAbilityMode = Math.max(
            0,
            Math.min(pendingBackgroundAbilityMode, modes.length - 1)
          );
          const currentMode = modes[pendingBackgroundAbilityMode];
          const modeButtons = document.createElement("div");
          modeButtons.className = "background-mode-options";
          modes.forEach((mode, idx) => {
            const btn = document.createElement("button");
            btn.type = "button";
            const weightLabel = mode.weights.map((value) => `+${value}`).join(" / ");
            btn.textContent = weightLabel;
            if (idx === pendingBackgroundAbilityMode) {
              btn.classList.add("selected");
            }
            btn.addEventListener("click", () => {
              pendingBackgroundAbilityMode = idx;
              pendingBackgroundAbilityAssignments = [];
              buildBackgroundConfigPanel(entry);
            });
            modeButtons.appendChild(btn);
          });
          abilitySection.appendChild(modeButtons);

          const defaults = currentMode.weights.map((_, idx) => currentMode.from[idx] || currentMode.from[0]);
          pendingBackgroundAbilityAssignments = ensureUniqueAbilityAssignments(
            pendingBackgroundAbilityAssignments.length ? pendingBackgroundAbilityAssignments : defaults,
            currentMode.from
          );

          currentMode.weights.forEach((weight, idx) => {
            const row = document.createElement("div");
            row.className = "background-choice-row";
            const label = document.createElement("label");
            label.textContent = `Choose ability for +${weight}`;
            const select = document.createElement("select");
            currentMode.from.forEach((ability) => {
              const option = document.createElement("option");
              option.value = ability;
              option.textContent = abilityKeyToLabel(ability);
              const takenByOther = pendingBackgroundAbilityAssignments.some(
                (assigned, assignedIdx) => assignedIdx !== idx && assigned === ability
              );
              option.disabled = takenByOther;
              if (pendingBackgroundAbilityAssignments[idx] === ability) {
                option.selected = true;
              }
              select.appendChild(option);
            });
            select.addEventListener("change", () => {
              pendingBackgroundAbilityAssignments[idx] = select.value;
              pendingBackgroundAbilityAssignments = ensureUniqueAbilityAssignments(
                pendingBackgroundAbilityAssignments,
                currentMode.from
              );
              buildBackgroundConfigPanel(entry);
            });
            row.appendChild(label);
            row.appendChild(select);
            abilitySection.appendChild(row);
          });
        }
        backgroundConfigBody.appendChild(abilitySection);

        const equipSection = document.createElement("div");
        equipSection.className = "background-config-section";
        const equipTitle = document.createElement("h4");
        equipTitle.textContent = "Starting Equipment";
        equipSection.appendChild(equipTitle);
        const choices = entry.startingEquipment?.[0] || {};
        const keys = Object.keys(choices);
        if (!keys.length) {
          const text = document.createElement("div");
          text.className = "spell-meta";
          text.textContent = "No equipment choices.";
          equipSection.appendChild(text);
        } else {
          if (!keys.includes(pendingBackgroundEquipmentChoice)) {
            pendingBackgroundEquipmentChoice = keys[0];
          }
          keys.forEach((key) => {
            const row = document.createElement("label");
            row.className = "background-choice-row";
            const input = document.createElement("input");
            input.type = "radio";
            input.name = "background-equip-choice";
            input.value = key;
            input.checked = pendingBackgroundEquipmentChoice === key;
            input.addEventListener("change", () => {
              pendingBackgroundEquipmentChoice = key;
            });
            const summary = summarizeEquipmentChoice(choices[key] || []);
            const text = document.createElement("span");
            text.textContent = `${key}: ${summary}`;
            row.appendChild(input);
            row.appendChild(text);
            equipSection.appendChild(row);
          });
        }
        backgroundConfigBody.appendChild(equipSection);

        const skillsSection = document.createElement("div");
        skillsSection.className = "background-config-section";
        const skillsTitle = document.createElement("h4");
        skillsTitle.textContent = "Skill Proficiencies";
        skillsSection.appendChild(skillsTitle);
        const skills = extractBackgroundSkillNames(entry);
        if (!skills.length) {
          const text = document.createElement("div");
          text.className = "spell-meta";
          text.textContent = "No skills configured.";
          skillsSection.appendChild(text);
        } else {
          const list = document.createElement("ul");
          list.className = "background-static-list";
          skills.forEach((skill) => {
            const li = document.createElement("li");
            li.textContent = skill;
            list.appendChild(li);
          });
          skillsSection.appendChild(list);
        }
        backgroundConfigBody.appendChild(skillsSection);
      }

      function applyBackgroundSelection(entry) {
        if (!entry) return;
        revertBackgroundEffects();

        const modes = getBackgroundAbilityModes(entry);
        if (modes.length) {
          const mode = modes[Math.max(0, Math.min(pendingBackgroundAbilityMode, modes.length - 1))];
          const selected = ensureUniqueAbilityAssignments(
            pendingBackgroundAbilityAssignments.slice(0, mode.weights.length),
            mode.from
          );
          const bonuses = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
          selected.forEach((ability, idx) => {
            if (!ability || !abilityScores[ability]) return;
            const bonus = Number(mode.weights[idx]) || 0;
            bonuses[ability] += bonus;
          });
          Object.entries(bonuses).forEach(([ability, bonus]) => {
            if (!bonus || !abilityScores[ability]) return;
            const current = toNumber(getListValue(abilityScores[ability]));
            setListValue(abilityScores[ability], String(current + bonus));
          });
          appliedBackgroundAbilityBonuses = bonuses;
        }

        const skills = extractBackgroundSkillNames(entry);
        setBackgroundSkillProficiencies(skills);
        appliedBackgroundFeatNames = normalizeFeatNameList(extractBackgroundFeatNames(entry));
        appliedBackgroundFeatChoiceSelections = {};
        rebuildSelectedFeatItems();
        recomputeFeatAbilityBonuses();
        renderTraitsList();
        updateAllSkillProficiencies();

        const choiceSet = entry.startingEquipment?.[0] || {};
        const selectedChoice = choiceSet[pendingBackgroundEquipmentChoice] || [];
        const parsed = parseEquipmentChoiceItems(selectedChoice);
        const inventoryAdds = [];
        const equipmentAdds = [];
        parsed.forEach((row) => {
          const qty = Math.max(1, Number(row.qty) || 1);
          const isWeapon = Boolean(getWeaponData(row.name));
          const isArmor = Boolean(getArmorData(row.name));
          for (let idx = 0; idx < qty; idx += 1) {
            if (!isWeapon && !isArmor) {
              inventoryItems.push(row.name);
              inventoryAdds.push(row.name);
            }
            if (isWeapon || isArmor) {
              const eq = createEquipmentItem(row.name);
              equipmentItems.push(eq);
              equipmentAdds.push(eq.id);
            }
          }
        });
        appliedBackgroundInventoryNames = inventoryAdds;
        appliedBackgroundEquipmentIds = equipmentAdds;
        appliedBackgroundName = entry.name || "";

        renderInventoryItems();
        renderEquipment();
        recalcDerived();
        buildCantripPickerList(spellSearch?.value || "");
      }

      function openBackgroundConfig(entry) {
        pendingBackgroundEntry = entry;
        pendingBackgroundAbilityMode = 0;
        pendingBackgroundAbilityAssignments = [];
        pendingBackgroundEquipmentChoice = "A";
        buildBackgroundConfigPanel(entry);
        setBackgroundConfigOpen(true);
      }

      function initEquipmentWeapons() {
        if (addWeaponBtn) {
          addWeaponBtn.addEventListener("click", () => {
            setPickerOpen(true);
            buildWeaponPickerList(weaponSearch?.value || "");
          });
        }
        if (weaponSearch) {
          weaponSearch.addEventListener("input", () => {
            buildWeaponPickerList(weaponSearch.value);
          });
        }
        if (weaponPickerAdd) {
          weaponPickerAdd.addEventListener("click", () => {
            if (!pickerSelected) return;
            equipmentItems = [...equipmentItems, createEquipmentItem(pickerSelected)];
            activeWeaponName = pickerSelected;
            updateActiveWeaponLabel();
            renderEquipment();
            scheduleSave();
            setPickerOpen(false);
          });
        }
        if (weaponPickerClose) {
          weaponPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setPickerOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setPickerOpen(false);
          }
        });
        buildWeaponPickerList("");
        updateActiveWeaponLabel();
      }

      function normalizeCantripItems(items) {
        if (!Array.isArray(items)) return [];
        const seen = new Set();
        return items
          .map((entry) => (typeof entry === "string" ? entry.trim() : ""))
          .filter((name) => name && !seen.has(name) && seen.add(name));
      }

      function normalizeInventoryItems(items) {
        if (!Array.isArray(items)) return [];
        return items.flatMap((entry) => {
          if (typeof entry === "string") {
            const name = entry.trim();
            return name ? [name] : [];
          }
          if (!entry || typeof entry !== "object") return [];
          const name = String(entry.name || "").trim();
          if (!name) return [];
          const qty = Math.max(1, Math.floor(Number(entry.qty || 1)));
          return Array.from({ length: qty }, () => name);
        });
      }

      function removeInventoryItem(name, qty = Number.POSITIVE_INFINITY) {
        const key = normalizeKey(name);
        let toRemove = Number.isFinite(Number(qty))
          ? Math.max(1, Math.floor(Number(qty)))
          : Number.POSITIVE_INFINITY;
        const next = [];
        inventoryItems.forEach((entry) => {
          if (normalizeKey(entry) === key && toRemove > 0) {
            toRemove -= 1;
            return;
          }
          next.push(entry);
        });
        inventoryItems = next;
        renderInventoryItems();
        scheduleSave();
      }

      function renderInventoryItems() {
        if (!itemsListEl) return;
        itemsListEl.innerHTML = "";
        if (!inventoryItems.length) {
          const empty = document.createElement("div");
          empty.className = "spell-meta";
          empty.textContent = "No items added.";
          itemsListEl.appendChild(empty);
          return;
        }

        const grouped = new Map();
        inventoryItems.forEach((name) => {
          const item = getItemDataByName(name) || { name, description: "", goldValue: "" };
          const key = normalizeKey(item.name || name);
          const existing = grouped.get(key);
          if (existing) {
            existing.qty += 1;
            return;
          }
          grouped.set(key, {
            key,
            name: item.name || name,
            description: item.description || "",
            goldValue: item.goldValue,
            qty: 1,
          });
        });

        const rows = Array.from(grouped.values()).sort((a, b) => a.name.localeCompare(b.name));
        const showQty = rows.some((entry) => entry.qty > 1);

        const header = document.createElement("div");
        header.className = `inventory-header${showQty ? " with-qty" : ""}`;
        header.innerHTML = showQty
          ? "<span>Name</span><span>Description</span><span>Gold</span><span>Qty</span><span>Remove Qty</span><span>Action</span>"
          : "<span>Name</span><span>Description</span><span>Gold</span><span>Action</span>";
        itemsListEl.appendChild(header);

        rows.forEach((entry) => {
          const row = document.createElement("div");
          row.className = `inventory-row${showQty ? " with-qty" : ""}`;

          const nameEl = document.createElement("div");
          nameEl.className = "inventory-name";
          nameEl.textContent = entry.name;
          nameEl.addEventListener("click", () => openInventoryItemPanel(entry.name));

          const descEl = document.createElement("div");
          descEl.className = "inventory-desc";
          descEl.textContent = entry.description || "--";
          descEl.title = entry.description || "";

          const goldEl = document.createElement("div");
          goldEl.className = "inventory-gold";
          goldEl.textContent = formatGoldValue(entry.goldValue);

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "inventory-remove";
          removeBtn.textContent = "Remove";

          row.appendChild(nameEl);
          row.appendChild(descEl);
          row.appendChild(goldEl);
          if (showQty) {
            const qtyEl = document.createElement("div");
            qtyEl.className = "inventory-qty";
            qtyEl.textContent = String(entry.qty);
            row.appendChild(qtyEl);
            if (entry.qty > 1) {
              const removeQtyInput = document.createElement("input");
              removeQtyInput.type = "number";
              removeQtyInput.className = "inventory-remove-qty";
              removeQtyInput.min = "1";
              removeQtyInput.max = String(entry.qty);
              removeQtyInput.step = "1";
              removeQtyInput.value = "1";
              removeQtyInput.setAttribute("aria-label", `Remove quantity for ${entry.name}`);
              removeBtn.addEventListener("click", () => {
                const requested = Math.max(1, Math.floor(Number(removeQtyInput.value) || 1));
                const removeCount = Math.min(entry.qty, requested);
                removeInventoryItem(entry.name, removeCount);
              });
              removeQtyInput.addEventListener("keydown", (event) => {
                if (event.key !== "Enter") return;
                const requested = Math.max(1, Math.floor(Number(removeQtyInput.value) || 1));
                const removeCount = Math.min(entry.qty, requested);
                removeInventoryItem(entry.name, removeCount);
              });
              row.appendChild(removeQtyInput);
            } else {
              const spacer = document.createElement("div");
              spacer.textContent = "";
              row.appendChild(spacer);
              removeBtn.addEventListener("click", () => removeInventoryItem(entry.name, 1));
            }
          } else {
            removeBtn.addEventListener("click", () => removeInventoryItem(entry.name, 1));
          }
          row.appendChild(removeBtn);
          itemsListEl.appendChild(row);
        });
      }

      function buildItemPickerList(filterText = "") {
        if (!itemPickerList) return;
        const filter = filterText.trim().toLowerCase();
        itemPickerList.innerHTML = "";

        if (!itemsLoaded) {
          const loading = document.createElement("div");
          loading.className = "weapon-option";
          loading.textContent = "Loading items...";
          itemPickerList.appendChild(loading);
          return;
        }
        if (!itemTable.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No items found.";
          itemPickerList.appendChild(empty);
          return;
        }

        const filtered = itemTable.filter((item) => {
          if (!filter) return true;
          return (
            item.name.toLowerCase().includes(filter) ||
            (item.description || "").toLowerCase().includes(filter)
          );
        });

        if (!filtered.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No items match your search.";
          itemPickerList.appendChild(empty);
          return;
        }

        const list = document.createElement("div");
        list.className = "weapon-list";
        filtered
          .slice()
          .sort((a, b) => a.name.localeCompare(b.name))
          .forEach((item) => {
            const option = document.createElement("div");
            option.className = "weapon-option";
            if (item.name === itemSelected) {
              option.classList.add("selected");
            }
            option.addEventListener("click", () => {
              itemSelected = item.name;
              if (itemPickerAdd) {
                itemPickerAdd.disabled = false;
              }
              openInventoryItemPanel(item.name);
              buildItemPickerList(itemSearch?.value || "");
            });
            const name = document.createElement("strong");
            name.textContent = item.name;
            const meta = document.createElement("span");
            meta.textContent = `${formatGoldValue(item.goldValue)} | ${item.description || "No description"}`;
            option.appendChild(name);
            option.appendChild(meta);
            list.appendChild(option);
          });
        itemPickerList.appendChild(list);
      }

      function renderCantrips() {
        if (!cantripPanel) return;
        cantripPanel.innerHTML = "";
        if (!cantripItems.length) {
          const empty = document.createElement("div");
          empty.className = "spell-meta";
          empty.textContent = "No cantrips added.";
          cantripPanel.appendChild(empty);
          return;
        }

        const list = document.createElement("div");
        list.className = "spell-list";
        cantripItems.forEach((name) => {
          const spell = cantripByName.get(name);
          const row = document.createElement("div");
          row.className = "spell-item";

          const info = document.createElement("div");
          info.style.cursor = "pointer";
          const title = document.createElement("strong");
          title.textContent = name;
          info.appendChild(title);

          if (spell) {
            const meta = document.createElement("div");
            meta.className = "spell-meta";
            const metaParts = [spell.school, spell.range].filter(Boolean);
            meta.textContent = metaParts.join("  ");
            info.appendChild(meta);
          }

          info.addEventListener("click", () => {
            if (!spell) return;
            openSpellPanel(spell);
          });

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "spell-remove";
          removeBtn.textContent = "Remove";
          removeBtn.addEventListener("click", () => {
            cantripItems = cantripItems.filter((item) => item !== name);
            renderCantrips();
            scheduleSave();
          });

          const rollBtn = document.createElement("button");
          rollBtn.type = "button";
          rollBtn.className = "spell-roll";
          rollBtn.textContent = "Roll";
          rollBtn.addEventListener("click", () => {
            rollSpellDamage(spell);
          });

          const actions = document.createElement("div");
          actions.className = "spell-item-actions";
          actions.appendChild(rollBtn);
          actions.appendChild(removeBtn);

          row.appendChild(info);
          row.appendChild(actions);
          list.appendChild(row);
        });

        cantripPanel.appendChild(list);
      }

      function renderSpellLevel1() {
        if (!spellLevel1Panel) return;
        const existingList = spellLevel1Panel.querySelector(".spell-list");
        if (existingList) existingList.remove();
        const existingEmpty = spellLevel1Panel.querySelector(".spell-meta");
        if (existingEmpty) existingEmpty.remove();

        if (!spellLevel1Items.length) {
          const empty = document.createElement("div");
          empty.className = "spell-meta";
          empty.textContent = "No level 1 spells added.";
          spellLevel1Panel.appendChild(empty);
          return;
        }

        const list = document.createElement("div");
        list.className = "spell-list";
        spellLevel1Items.forEach((name) => {
          const spell = spellLevel1ByName.get(name);
          const row = document.createElement("div");
          row.className = "spell-item";

          const info = document.createElement("div");
          info.style.cursor = "pointer";
          const title = document.createElement("strong");
          title.textContent = name;
          info.appendChild(title);

          if (spell) {
            const meta = document.createElement("div");
            meta.className = "spell-meta";
            const metaParts = [spell.school, spell.range].filter(Boolean);
            meta.textContent = metaParts.join(" | ");
            info.appendChild(meta);
          }

          info.addEventListener("click", () => {
            if (!spell) return;
            openSpellPanel(spell);
          });

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "spell-remove";
          removeBtn.textContent = "Remove";
          removeBtn.addEventListener("click", () => {
            spellLevel1Items = spellLevel1Items.filter((item) => item !== name);
            renderSpellLevel1();
            scheduleSave();
          });

          const rollBtn = document.createElement("button");
          rollBtn.type = "button";
          rollBtn.className = "spell-roll";
          rollBtn.textContent = "Roll";
          rollBtn.addEventListener("click", () => {
            rollSpellDamage(spell);
          });

          const actions = document.createElement("div");
          actions.className = "spell-item-actions";
          actions.appendChild(rollBtn);
          actions.appendChild(removeBtn);

          row.appendChild(info);
          row.appendChild(actions);
          list.appendChild(row);
        });

        spellLevel1Panel.appendChild(list);
      }

      function renderSpellLevel2() {
        if (!spellLevel2Panel) return;
        const existingList = spellLevel2Panel.querySelector(".spell-list");
        if (existingList) existingList.remove();
        const existingEmpty = spellLevel2Panel.querySelector(".spell-meta");
        if (existingEmpty) existingEmpty.remove();

        if (!spellLevel2Items.length) {
          const empty = document.createElement("div");
          empty.className = "spell-meta";
          empty.textContent = "No level 2 spells added.";
          spellLevel2Panel.appendChild(empty);
          return;
        }

        const list = document.createElement("div");
        list.className = "spell-list";
        spellLevel2Items.forEach((name) => {
          const spell = spellLevel2ByName.get(name);
          const row = document.createElement("div");
          row.className = "spell-item";

          const info = document.createElement("div");
          info.style.cursor = "pointer";
          const title = document.createElement("strong");
          title.textContent = name;
          info.appendChild(title);

          if (spell) {
            const meta = document.createElement("div");
            meta.className = "spell-meta";
            const metaParts = [spell.school, spell.range].filter(Boolean);
            meta.textContent = metaParts.join(" | ");
            info.appendChild(meta);
          }

          info.addEventListener("click", () => {
            if (!spell) return;
            openSpellPanel(spell);
          });

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "spell-remove";
          removeBtn.textContent = "Remove";
          removeBtn.addEventListener("click", () => {
            spellLevel2Items = spellLevel2Items.filter((item) => item !== name);
            renderSpellLevel2();
            scheduleSave();
          });

          const rollBtn = document.createElement("button");
          rollBtn.type = "button";
          rollBtn.className = "spell-roll";
          rollBtn.textContent = "Roll";
          rollBtn.addEventListener("click", () => {
            rollSpellDamage(spell);
          });

          const actions = document.createElement("div");
          actions.className = "spell-item-actions";
          actions.appendChild(rollBtn);
          actions.appendChild(removeBtn);

          row.appendChild(info);
          row.appendChild(actions);
          list.appendChild(row);
        });

        spellLevel2Panel.appendChild(list);
      }

      function renderSpellLevel3() {
        if (!spellLevel3Panel) return;
        const existingList = spellLevel3Panel.querySelector(".spell-list");
        if (existingList) existingList.remove();
        const existingEmpty = spellLevel3Panel.querySelector(".spell-meta");
        if (existingEmpty) existingEmpty.remove();

        if (!spellLevel3Items.length) {
          const empty = document.createElement("div");
          empty.className = "spell-meta";
          empty.textContent = "No level 3 spells added.";
          spellLevel3Panel.appendChild(empty);
          return;
        }

        const list = document.createElement("div");
        list.className = "spell-list";
        spellLevel3Items.forEach((name) => {
          const spell = spellLevel3ByName.get(name);
          const row = document.createElement("div");
          row.className = "spell-item";

          const info = document.createElement("div");
          info.style.cursor = "pointer";
          const title = document.createElement("strong");
          title.textContent = name;
          info.appendChild(title);

          if (spell) {
            const meta = document.createElement("div");
            meta.className = "spell-meta";
            const metaParts = [spell.school, spell.range].filter(Boolean);
            meta.textContent = metaParts.join(" | ");
            info.appendChild(meta);
          }

          info.addEventListener("click", () => {
            if (!spell) return;
            openSpellPanel(spell);
          });

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "spell-remove";
          removeBtn.textContent = "Remove";
          removeBtn.addEventListener("click", () => {
            spellLevel3Items = spellLevel3Items.filter((item) => item !== name);
            renderSpellLevel3();
            scheduleSave();
          });

          const rollBtn = document.createElement("button");
          rollBtn.type = "button";
          rollBtn.className = "spell-roll";
          rollBtn.textContent = "Roll";
          rollBtn.addEventListener("click", () => {
            rollSpellDamage(spell);
          });

          const actions = document.createElement("div");
          actions.className = "spell-item-actions";
          actions.appendChild(rollBtn);
          actions.appendChild(removeBtn);

          row.appendChild(info);
          row.appendChild(actions);
          list.appendChild(row);
        });

        spellLevel3Panel.appendChild(list);
      }

      function renderSpellSlotSquares(slotCountsByLevel = null) {
        const counts = slotCountsByLevel && typeof slotCountsByLevel === "object"
          ? slotCountsByLevel
          : { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0 };
        const slotCounts = {
          "spell-panel-2": counts[1] || 0,
          "spell-panel-3": counts[2] || 0,
          "spell-panel-4": counts[3] || 0,
          "spell-panel-5": counts[4] || 0,
          "spell-panel-6": counts[5] || 0,
          "spell-panel-7": counts[6] || 0,
          "spell-panel-8": counts[7] || 0,
          "spell-panel-9": counts[8] || 0,
          "spell-panel-10": counts[9] || 0,
        };
        Object.entries(slotCounts).forEach(([panelId, count]) => {
          const panel = document.getElementById(panelId);
          if (!panel) return;
          panel.innerHTML = "";
          const grid = document.createElement("div");
          grid.className = "spell-slot-grid";
          for (let i = 0; i < Math.max(0, Math.floor(Number(count) || 0)); i += 1) {
            const square = document.createElement("div");
            square.className = "spell-list-anchor";
            square.setAttribute("aria-label", `Spell slot ${i + 1}`);
            square.title = `Spell slot ${i + 1}`;
            grid.appendChild(square);
          }
          panel.appendChild(grid);
        });
        renderSpellLevel1();
        renderSpellLevel2();
        renderSpellLevel3();
      }

      function initSpellPicker() {
        const refreshSpellPickerForCurrentTab = () => {
          cantripSelected = "";
          if (spellPickerAdd) {
            spellPickerAdd.disabled = !cantripSelected || !canLearnAnotherSpellAtLevel(getActiveSpellTabLevel());
          }
          buildCantripPickerList(spellSearch?.value || "");
          if (spellSearch) {
            const level = getActiveSpellTabLevel();
            spellSearch.placeholder = level === 1
              ? "Search level 1 spells..."
              : level === 2
                ? "Search level 2 spells..."
                : level === 3
                  ? "Search level 3 spells..."
                  : level > 3
                    ? `No spell data for level ${level}...`
                    : "Search cantrips...";
          }
        };

        if (addSpellBtn) {
          addSpellBtn.addEventListener("click", () => {
            if (itemPanel) {
              itemPanel.classList.remove("open");
              itemPanel.setAttribute("aria-hidden", "true");
            }
            setSpellPickerOpen(true);
            refreshSpellPickerForCurrentTab();
          });
        }
        if (spellSearch) {
          spellSearch.addEventListener("input", () => {
            buildCantripPickerList(spellSearch.value);
          });
        }
        if (spellPickerAdd) {
          spellPickerAdd.addEventListener("click", () => {
            if (!cantripSelected) return;
            const activeLevel = getActiveSpellTabLevel();
            if (!canLearnAnotherSpellAtLevel(activeLevel)) {
              setSpellPickerOpen(false);
              return;
            }
            if (activeLevel === 1) {
              if (!spellLevel1Items.includes(cantripSelected)) {
                spellLevel1Items = [...spellLevel1Items, cantripSelected];
                renderSpellLevel1();
                scheduleSave();
              }
            } else if (activeLevel === 2) {
              if (!spellLevel2Items.includes(cantripSelected)) {
                spellLevel2Items = [...spellLevel2Items, cantripSelected];
                renderSpellLevel2();
                scheduleSave();
              }
            } else if (activeLevel === 3) {
              if (!spellLevel3Items.includes(cantripSelected)) {
                spellLevel3Items = [...spellLevel3Items, cantripSelected];
                renderSpellLevel3();
                scheduleSave();
              }
            } else if (activeLevel > 3) {
              setSpellPickerOpen(false);
              return;
            } else {
              if (!cantripItems.includes(cantripSelected)) {
                cantripItems = [...cantripItems, cantripSelected];
                renderCantrips();
                scheduleSave();
              }
            }
            if (itemPanel) {
              itemPanel.classList.remove("open");
              itemPanel.setAttribute("aria-hidden", "true");
            }
            setSpellPickerOpen(false);
          });
        }
        if (spellPickerClose) {
          spellPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setSpellPickerOpen(false);
          });
        }
        if (removeSpellBtn) {
          removeSpellBtn.addEventListener("click", () => {
            const activeLevel = getActiveSpellTabLevel();
            if (activeLevel === 1) {
              if (!spellLevel1Items.length) return;
              spellLevel1Items = spellLevel1Items.slice(0, -1);
              renderSpellLevel1();
              scheduleSave();
              return;
            }
            if (activeLevel === 2) {
              if (!spellLevel2Items.length) return;
              spellLevel2Items = spellLevel2Items.slice(0, -1);
              renderSpellLevel2();
              scheduleSave();
              return;
            }
            if (activeLevel === 3) {
              if (!spellLevel3Items.length) return;
              spellLevel3Items = spellLevel3Items.slice(0, -1);
              renderSpellLevel3();
              scheduleSave();
              return;
            }
            if (activeLevel > 3) return;
            if (!cantripItems.length) return;
            cantripItems = cantripItems.slice(0, -1);
            renderCantrips();
            scheduleSave();
          });
        }
        spellTabInputs.forEach((input) => {
          input.addEventListener("change", () => {
            refreshSpellPickerForCurrentTab();
          });
        });
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setSpellPickerOpen(false);
          }
        });
        refreshSpellPickerForCurrentTab();
        renderCantrips();
        renderSpellLevel1();
        renderSpellLevel2();
        renderSpellLevel3();
      }

      function initFeatPicker() {
        if (featSearch) {
          featSearch.addEventListener("input", () => {
            buildFeatPickerList(featSearch.value);
          });
        }
        if (featPickerAdd) {
          featPickerAdd.addEventListener("click", () => {
            if (!featSelected) return;
            applyFeatSelection(featSelected);
            if (itemPanel) {
              itemPanel.classList.remove("open");
              itemPanel.setAttribute("aria-hidden", "true");
            }
            setFeatPickerOpen(false);
          });
        }
        if (featPickerClose) {
          featPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setFeatPickerOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setFeatPickerOpen(false);
          }
        });
        buildFeatPickerList("");
      }

      function initFeatChoicePicker() {
        if (featChoiceApply) {
          featChoiceApply.addEventListener("click", () => {
            const context = pendingFeatChoiceContext;
            if (!context) return;
            if (featChoiceApply.disabled) return;
            commitFeatSelection(context.featName, context.level, context.selections);
            if (itemPanel) {
              itemPanel.classList.remove("open");
              itemPanel.setAttribute("aria-hidden", "true");
            }
            setFeatChoicePickerOpen(false);
            setFeatPickerOpen(false);
          });
        }
        if (featChoiceClose) {
          featChoiceClose.addEventListener("click", (event) => {
            event.stopPropagation();
            const context = pendingFeatChoiceContext;
            setFeatChoicePickerOpen(false);
            if (context?.level && !featSelectionsByLevel[String(context.level)]) {
              featPromptLevel = context.level;
              setFeatPickerOpen(true);
              buildFeatPickerList(featSearch?.value || "");
            }
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            const context = pendingFeatChoiceContext;
            setFeatChoicePickerOpen(false);
            if (context?.level && !featSelectionsByLevel[String(context.level)]) {
              featPromptLevel = context.level;
              setFeatPickerOpen(true);
              buildFeatPickerList(featSearch?.value || "");
            }
          }
        });
      }

      function initItemPicker() {
        if (addItemBtn) {
          addItemBtn.addEventListener("click", () => {
            setItemPickerOpen(true);
            buildItemPickerList(itemSearch?.value || "");
          });
        }
        if (itemSearch) {
          itemSearch.addEventListener("input", () => {
            buildItemPickerList(itemSearch.value);
          });
        }
        if (itemPickerAdd) {
          itemPickerAdd.addEventListener("click", () => {
            if (!itemSelected) return;
            inventoryItems = [...inventoryItems, itemSelected];
            renderInventoryItems();
            scheduleSave();
            setItemPickerOpen(false);
          });
        }
        if (itemPickerClose) {
          itemPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setItemPickerOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setItemPickerOpen(false);
          }
        });
        buildItemPickerList("");
        renderInventoryItems();
      }

      function initRacePicker() {
        if (raceInput) {
          const openPicker = () => {
            setRacePickerOpen(true);
            if (raceInput.value && raceList.includes(raceInput.value)) {
              raceSelected = raceInput.value;
              if (racePickerAdd) {
                racePickerAdd.disabled = false;
              }
              const existing = raceByName.get(raceInput.value);
              if (existing) {
                openRacePanel(existing);
              }
            }
            buildRacePickerList(raceSearch?.value || "");
          };
          raceInput.addEventListener("click", openPicker);
          raceInput.addEventListener("focus", openPicker);
          raceInput.addEventListener("input", () => {
            if (raceByName.has(raceInput.value)) {
              applyRaceSelection(raceInput.value);
            }
          });
        }
        if (raceSearch) {
          raceSearch.addEventListener("input", () => {
            buildRacePickerList(raceSearch.value);
          });
        }
        if (racePickerAdd) {
          racePickerAdd.addEventListener("click", () => {
            if (!raceSelected || !raceInput) return;
            const shouldRequireClass = racePickerLocked;
            const raceEntry = raceByName.get(raceSelected);
            raceInput.value = raceSelected;
            applyRaceSelection(raceSelected, { promptForSize: true });
            scheduleSave();
            racePickerLocked = false;
            setRacePickerOpen(false);
            if (raceEntry && getRaceSubclassNames(raceEntry).length) {
              openRaceSubclassPicker(raceEntry, {
                required: shouldRequireClass,
                onComplete: () => {
                  scheduleSave();
                  if (shouldRequireClass) {
                    startRequiredClassSelection();
                  }
                },
              });
              return;
            }
            if (shouldRequireClass) {
              startRequiredClassSelection();
            }
          });
        }
        if (racePickerClose) {
          racePickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            if (racePickerLocked) return;
            setRacePickerOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            if (racePickerLocked) return;
            setRacePickerOpen(false);
          }
        });
        buildRacePickerList("");
      }

      function initSizePicker() {
        if (sizePickerClose) {
          sizePickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setSizePickerOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setSizePickerOpen(false);
          }
        });
      }

      function initAlignmentPicker() {
        if (subclassInput) {
          const openSubclassPicker = () => {
            const className = String(classInput?.value || "").trim();
            if (!className || !classesLoaded) return;
            const entry = classByName.get(className);
            if (!entry || !getClassSubclassNames(entry).length) return;
            openAlignmentPicker(entry, { required: false, finalizeOnPick: false });
          };
          subclassInput.addEventListener("click", openSubclassPicker);
          subclassInput.addEventListener("focus", openSubclassPicker);
        }
        if (alignmentPickerAdd) {
          alignmentPickerAdd.addEventListener("click", (event) => {
            event.stopPropagation();
            commitPendingSubclassSelection();
          });
        }
        if (alignmentPickerClose) {
          alignmentPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            if (subclassPickerLocked) return;
            setAlignmentPickerOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            if (subclassPickerLocked) return;
            setAlignmentPickerOpen(false);
          }
        });
      }

      function initAbilityPicker() {
        if (abilityPickerClose) {
          abilityPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            if (abilityPickerLocked) return;
            setAbilityPickerOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            if (abilityPickerLocked) return;
            setAbilityPickerOpen(false);
          }
        });
      }

      function initClassPicker() {
        if (classInput) {
          const openPicker = () => {
            setClassPickerOpen(true);
            if (classInput.value && classByName.has(classInput.value)) {
              classSelected = classInput.value;
              if (classPickerAdd) {
                classPickerAdd.disabled = false;
              }
              const existing = classByName.get(classInput.value);
              if (existing) {
                openClassPanel(existing);
              }
            }
            buildClassPickerList(classSearch?.value || "");
          };
          classInput.addEventListener("click", openPicker);
          classInput.addEventListener("focus", openPicker);
        }
        if (classSearch) {
          classSearch.addEventListener("input", () => {
            buildClassPickerList(classSearch.value);
          });
        }
        if (classPickerAdd) {
          classPickerAdd.addEventListener("click", () => {
            commitClassPickerSelection();
          });
        }
        if (classPickerClose) {
          classPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            if (classPickerLocked) return;
            setClassPickerOpen(false);
          });
        }
        if (classEquipmentApply) {
          classEquipmentApply.addEventListener("click", () => {
            if (!pendingClassEquipmentEntry) return;
            applyClassStartingEquipment(pendingClassEquipmentEntry);
            scheduleSave();
            setClassEquipmentOpen(false);
            if (requireBackgroundAfterClassEquipment) {
              requireBackgroundAfterClassEquipment = false;
              startRequiredBackgroundSelection();
            }
          });
        }
        if (classEquipmentClose) {
          classEquipmentClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setClassEquipmentOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            if (classPickerLocked) return;
            setClassPickerOpen(false);
            setClassEquipmentOpen(false);
          }
        });
        buildClassPickerList("");
      }

      function initBackgroundPicker() {
        if (backgroundInput) {
          const openPicker = () => {
            setBackgroundPickerOpen(true);
            if (backgroundInput.value && backgroundByName.has(backgroundInput.value)) {
              backgroundSelected = backgroundInput.value;
              if (backgroundPickerAdd) {
                backgroundPickerAdd.disabled = false;
              }
              const existing = backgroundByName.get(backgroundInput.value);
              if (existing) {
                openBackgroundPanel(existing);
              }
            }
            buildBackgroundPickerList(backgroundSearch?.value || "");
          };
          backgroundInput.addEventListener("click", openPicker);
          backgroundInput.addEventListener("focus", openPicker);
          backgroundInput.addEventListener("input", () => {
            if (backgroundByName.has(backgroundInput.value)) {
              const entry = backgroundByName.get(backgroundInput.value);
              if (entry) {
                openBackgroundPanel(entry);
              }
            }
          });
        }
        if (backgroundSearch) {
          backgroundSearch.addEventListener("input", () => {
            buildBackgroundPickerList(backgroundSearch.value);
          });
        }
        if (backgroundPickerAdd) {
          backgroundPickerAdd.addEventListener("click", () => {
            if (!backgroundSelected || !backgroundInput) return;
            const requiresConfig = backgroundPickerLocked;
            backgroundInput.value = backgroundSelected;
            const entry = backgroundByName.get(backgroundSelected);
            backgroundPickerLocked = false;
            setBackgroundPickerOpen(false);
            if (entry) {
              openBackgroundPanel(entry);
              backgroundConfigLocked = requiresConfig;
              openBackgroundConfig(entry);
            }
          });
        }
        if (backgroundPickerClose) {
          backgroundPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            if (backgroundPickerLocked) return;
            setBackgroundPickerOpen(false);
          });
        }
        if (backgroundConfigApply) {
          backgroundConfigApply.addEventListener("click", () => {
            if (!pendingBackgroundEntry) return;
            applyBackgroundSelection(pendingBackgroundEntry);
            scheduleSave();
            const wasRequiredConfig = backgroundConfigLocked;
            backgroundConfigLocked = false;
            setBackgroundConfigOpen(false);
            if (wasRequiredConfig) {
              const classEntry = pendingBackgroundClassEntry;
              pendingBackgroundClassEntry = null;
              newCharacterSetupFlowActive = false;
              if (classEntry) {
                openClassEquipmentPicker(classEntry);
              }
            }
          });
        }
        if (backgroundConfigClose) {
          backgroundConfigClose.addEventListener("click", (event) => {
            event.stopPropagation();
            if (backgroundConfigLocked) return;
            setBackgroundConfigOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            if (backgroundPickerLocked || backgroundConfigLocked) return;
            setBackgroundPickerOpen(false);
            setBackgroundConfigOpen(false);
          }
        });
        buildBackgroundPickerList("");
      }

      function buildSheetPayload() {
        const payload = {};
        for (const el of fieldEls) {
          payload[el.id] = getFieldValue(el);
        }
        computedDisplayEls.forEach((el) => {
          if (el?.id) {
            payload[el.id] = getListValue(el);
          }
        });
        Object.values(abilityScores).forEach((el) => {
          if (el?.id) {
            payload[el.id] = getListValue(el);
          }
        });
        payload.equipmentItems = equipmentItems.slice();
        payload.inventoryItems = inventoryItems.slice();
        payload.cantripItems = cantripItems.slice();
        payload.spellLevel1Items = spellLevel1Items.slice();
        payload.spellLevel2Items = spellLevel2Items.slice();
        payload.spellLevel3Items = spellLevel3Items.slice();
        payload.equippedMainId = equippedMainId;
        payload.equippedOffhandId = equippedOffhandId;
        payload.equippedMainTwoHanded = equippedMainTwoHanded;
        payload.equippedArmorId = equippedArmorId;
        payload.equippedShieldId = equippedShieldId;
        payload.appliedBackgroundName = appliedBackgroundName;
        payload.appliedBackgroundAbilityBonuses = { ...appliedBackgroundAbilityBonuses };
        payload.appliedBackgroundSkillIds = appliedBackgroundSkillIds.slice();
        payload.appliedBackgroundInventoryNames = appliedBackgroundInventoryNames.slice();
        payload.appliedBackgroundEquipmentIds = appliedBackgroundEquipmentIds.slice();
        payload.appliedBackgroundFeatNames = appliedBackgroundFeatNames.slice();
        payload.appliedBackgroundFeatChoiceSelections = { ...appliedBackgroundFeatChoiceSelections };
        payload.pendingBackgroundAbilityMode = pendingBackgroundAbilityMode;
        payload.pendingBackgroundAbilityAssignments = pendingBackgroundAbilityAssignments.slice();
        payload.pendingBackgroundEquipmentChoice = pendingBackgroundEquipmentChoice;
        payload.appliedClassEquipmentName = appliedClassEquipmentName;
        payload.appliedClassInventoryNames = appliedClassInventoryNames.slice();
        payload.appliedClassEquipmentIds = appliedClassEquipmentIds.slice();
        payload.selectedRaceSubclass = selectedRaceSubclass;
        payload.selectedFeatItems = selectedFeatItems.slice();
        payload.featSelectionsByLevel = { ...featSelectionsByLevel };
        payload.featChoiceSelectionsByLevel = { ...featChoiceSelectionsByLevel };
        payload.appliedFeatAbilityBonuses = { ...appliedFeatAbilityBonuses };
        return payload;
      }

      function saveLocalSheet(payload) {
        try {
          localStorage.setItem(LOCAL_SHEET_STORAGE_KEY, JSON.stringify(payload));
        } catch (error) {
          console.error("Failed to save local sheet", error);
        }
      }

      function buildBlankSheetData() {
        const payload = {};
        for (const el of fieldEls) {
          payload[el.id] = el.type === "checkbox" ? false : "";
        }
        payload.level = "1";
        payload.equipmentItems = [];
        payload.inventoryItems = [];
        payload.cantripItems = [];
        payload.spellLevel1Items = [];
        payload.spellLevel2Items = [];
        payload.spellLevel3Items = [];
        payload.equippedMainId = "";
        payload.equippedOffhandId = "";
        payload.equippedMainTwoHanded = false;
        payload.equippedArmorId = "";
        payload.equippedShieldId = "";
        payload.appliedBackgroundName = "";
        payload.appliedBackgroundAbilityBonuses = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
        payload.appliedBackgroundSkillIds = [];
        payload.appliedBackgroundInventoryNames = [];
        payload.appliedBackgroundEquipmentIds = [];
        payload.appliedBackgroundFeatNames = [];
        payload.appliedBackgroundFeatChoiceSelections = {};
        payload.pendingBackgroundAbilityMode = 0;
        payload.pendingBackgroundAbilityAssignments = [];
        payload.pendingBackgroundEquipmentChoice = "A";
        payload.appliedClassEquipmentName = "";
        payload.appliedClassInventoryNames = [];
        payload.appliedClassEquipmentIds = [];
        payload.selectedRaceSubclass = "";
        payload.selectedFeatItems = [];
        payload.featSelectionsByLevel = FEAT_LEVEL_MILESTONES.reduce((acc, level) => {
          acc[String(level)] = "";
          return acc;
        }, {});
        payload.featChoiceSelectionsByLevel = FEAT_LEVEL_MILESTONES.reduce((acc, level) => {
          acc[String(level)] = {};
          return acc;
        }, {});
        payload.appliedFeatAbilityBonuses = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
        return payload;
      }

      function setStartupModalOpen(isOpen) {
        document.body.classList.toggle("startup-modal-open", Boolean(isOpen));
        if (startupModalOverlay) {
          startupModalOverlay.setAttribute("aria-hidden", isOpen ? "false" : "true");
        }
        if (isOpen) {
          startupNewCharacterBtn?.focus();
        }
      }

      async function startNewCharacter() {
        const blank = buildBlankSheetData();
        try {
          localStorage.removeItem(LOCAL_SHEET_STORAGE_KEY);
        } catch (error) {
          console.error("Failed to clear local sheet", error);
        }
        applySheetData(blank);
        const payload = buildSheetPayload();
        saveLocalSheet(payload);
        try {
          await setDoc(sheetRef, payload);
          const fresh = await getDocFromServer(sheetRef);
          if (fresh.exists()) {
            applySheetData(fresh.data());
            saveLocalSheet(buildSheetPayload());
          }
        } catch (error) {
          console.error("Failed to save new character sheet", error);
        }
      }

      function applySheetData(data) {
        if (!data) {
          applyBaseDefaults();
          recalcDerived();
          return;
        }
        isRemoteUpdate = true;
        fieldEls.forEach((el) => {
          applyFieldValue(el, data[el.id]);
        });
        computedDisplayEls.forEach((el) => {
          if (el?.id && data[el.id] !== undefined) {
            setListValue(el, data[el.id]);
          }
        });
        Object.values(abilityScores).forEach((el) => {
          if (el?.id && data[el.id] !== undefined) {
            setListValue(el, data[el.id]);
          }
        });
        if (subclassInput) {
          const className = String(classInput?.value || "").trim();
          const classEntry = classByName.get(className);
          syncSubclassInputForClass(classEntry || null);
        }
        if (classInput?.value && classesLoaded) {
          const entry = classByName.get(classInput.value);
          if (entry) {
            applyClassSelection(entry, { rollHp: false });
          }
        }
        featSelectionsByLevel = normalizeFeatSelectionMap(data.featSelectionsByLevel);
        featChoiceSelectionsByLevel = normalizeFeatChoiceSelectionMap(data.featChoiceSelectionsByLevel);
        const hasIncomingFeatBonuses = data.appliedFeatAbilityBonuses && typeof data.appliedFeatAbilityBonuses === "object";
        appliedFeatAbilityBonuses = normalizeAbilityBonusMap(data.appliedFeatAbilityBonuses);
        if (Array.isArray(data.selectedFeatItems) && data.selectedFeatItems.length) {
          selectedFeatItems = data.selectedFeatItems
            .map((entry) => String(entry || "").trim())
            .filter(Boolean);
          const hasExplicitLevelFeats = FEAT_LEVEL_MILESTONES.some(
            (level) => Boolean(String(featSelectionsByLevel[String(level)] || "").trim())
          );
          if (!hasExplicitLevelFeats) {
            const backgroundFeatSet = new Set(
              normalizeFeatNameList(data.appliedBackgroundFeatNames).map((entry) => normalizeKey(entry))
            );
            const legacyLevelFeats = selectedFeatItems.filter(
              (featName) => !backgroundFeatSet.has(normalizeKey(featName))
            );
            const currentLevel = Math.min(
              Math.max(toNumber(data.level ?? getListValue(levelEl)) || 1, 1),
              20
            );
            const unlockedMilestones = FEAT_LEVEL_MILESTONES.filter((level) => level <= currentLevel);
            unlockedMilestones.forEach((level, index) => {
              const key = String(level);
              if (!featSelectionsByLevel[key] && legacyLevelFeats[index]) {
                featSelectionsByLevel[key] = legacyLevelFeats[index];
              }
            });
          }
        } else {
          rebuildSelectedFeatItems();
        }
        if (!hasIncomingFeatBonuses) {
          recomputeFeatAbilityBonuses();
        }
        applyRaceSelection(raceInput?.value || "");
        if (Array.isArray(data.equipmentItems)) {
          equipmentItems = normalizeEquipmentItems(data.equipmentItems);
          equippedMainId = data.equippedMainId || "";
          equippedOffhandId = data.equippedOffhandId || "";
          equippedMainTwoHanded = Boolean(data.equippedMainTwoHanded);
          equippedArmorId = data.equippedArmorId || "";
          equippedShieldId = data.equippedShieldId || "";
          if (!equipmentItems.some((item) => item.id === equippedMainId)) {
            equippedMainId = "";
          }
          if (!equipmentItems.some((item) => item.id === equippedOffhandId)) {
            equippedOffhandId = "";
          }
          if (!equipmentItems.some((item) => item.id === equippedArmorId)) {
            equippedArmorId = "";
          }
          if (!equipmentItems.some((item) => item.id === equippedShieldId)) {
            equippedShieldId = "";
          }
          if (!equippedMainId) {
            equippedMainTwoHanded = false;
          } else {
            const mainItem = getEquippedWeaponById(equippedMainId);
            const mainWeapon = mainItem ? getWeaponData(mainItem.name) : null;
            if (!isVersatileWeapon(mainWeapon)) {
              equippedMainTwoHanded = Boolean(mainWeapon?.properties.includes("Two-Handed"));
            }
          }
          if (!equipmentItems.some((item) => item.name === activeWeaponName)) {
            activeWeaponName = equipmentItems[0]?.name || "";
          }
          updateActiveWeaponLabel();
          renderEquipment();
          appliedClassEquipmentIds = appliedClassEquipmentIds
            .filter((id) => equipmentItems.some((item) => item.id === id));
          appliedBackgroundEquipmentIds = appliedBackgroundEquipmentIds
            .filter((id) => equipmentItems.some((item) => item.id === id));
        }
        if (Array.isArray(data.cantripItems)) {
          cantripItems = normalizeCantripItems(data.cantripItems);
          renderCantrips();
        }
        if (Array.isArray(data.spellLevel1Items)) {
          spellLevel1Items = normalizeCantripItems(data.spellLevel1Items);
          renderSpellLevel1();
        }
        if (Array.isArray(data.spellLevel2Items)) {
          spellLevel2Items = normalizeCantripItems(data.spellLevel2Items);
          renderSpellLevel2();
        }
        if (Array.isArray(data.spellLevel3Items)) {
          spellLevel3Items = normalizeCantripItems(data.spellLevel3Items);
          renderSpellLevel3();
        }
        if (Array.isArray(data.inventoryItems)) {
          inventoryItems = normalizeInventoryItems(data.inventoryItems);
          renderInventoryItems();
        }
        appliedBackgroundName = typeof data.appliedBackgroundName === "string"
          ? data.appliedBackgroundName
          : "";
        const incomingBonuses = data.appliedBackgroundAbilityBonuses;
        appliedBackgroundAbilityBonuses = {
          str: Number(incomingBonuses?.str) || 0,
          dex: Number(incomingBonuses?.dex) || 0,
          con: Number(incomingBonuses?.con) || 0,
          int: Number(incomingBonuses?.int) || 0,
          wis: Number(incomingBonuses?.wis) || 0,
          cha: Number(incomingBonuses?.cha) || 0,
        };
        appliedBackgroundSkillIds = Array.isArray(data.appliedBackgroundSkillIds)
          ? data.appliedBackgroundSkillIds.map((entry) => String(entry || "")).filter(Boolean)
          : [];
        appliedBackgroundInventoryNames = Array.isArray(data.appliedBackgroundInventoryNames)
          ? data.appliedBackgroundInventoryNames.map((entry) => String(entry || "")).filter(Boolean)
          : [];
        appliedBackgroundEquipmentIds = Array.isArray(data.appliedBackgroundEquipmentIds)
          ? data.appliedBackgroundEquipmentIds.map((entry) => String(entry || "")).filter(Boolean)
          : [];
        appliedBackgroundFeatNames = normalizeFeatNameList(data.appliedBackgroundFeatNames);
        appliedBackgroundFeatChoiceSelections = normalizeBackgroundFeatChoiceSelectionMap(data.appliedBackgroundFeatChoiceSelections);
        pendingBackgroundAbilityMode = Number.isFinite(Number(data.pendingBackgroundAbilityMode))
          ? Number(data.pendingBackgroundAbilityMode)
          : 0;
        pendingBackgroundAbilityAssignments = Array.isArray(data.pendingBackgroundAbilityAssignments)
          ? data.pendingBackgroundAbilityAssignments
            .map((entry) => normalizeAbilityKey(entry))
            .filter(Boolean)
          : [];
        pendingBackgroundEquipmentChoice = typeof data.pendingBackgroundEquipmentChoice === "string"
          ? data.pendingBackgroundEquipmentChoice
          : "A";
        appliedClassEquipmentName = typeof data.appliedClassEquipmentName === "string"
          ? data.appliedClassEquipmentName
          : "";
        appliedClassInventoryNames = Array.isArray(data.appliedClassInventoryNames)
          ? data.appliedClassInventoryNames.map((entry) => String(entry || "")).filter(Boolean)
          : [];
        appliedClassEquipmentIds = Array.isArray(data.appliedClassEquipmentIds)
          ? data.appliedClassEquipmentIds.map((entry) => String(entry || "")).filter(Boolean)
          : [];
        selectedRaceSubclass = typeof data.selectedRaceSubclass === "string"
          ? data.selectedRaceSubclass.trim()
          : "";
        appliedClassEquipmentIds = appliedClassEquipmentIds
          .filter((id) => equipmentItems.some((item) => item.id === id));
        appliedBackgroundEquipmentIds = appliedBackgroundEquipmentIds
          .filter((id) => equipmentItems.some((item) => item.id === id));
        rebuildSelectedFeatItems();
        updateAllSkillProficiencies();
        renderTraitsList();
        applyBaseDefaults();
        recalcDerived();
        isRemoteUpdate = false;
      }

      function loadLocalSheet() {
        try {
          const raw = localStorage.getItem(LOCAL_SHEET_STORAGE_KEY);
          if (!raw) return;
          const data = JSON.parse(raw);
          applySheetData(data);
        } catch (error) {
          console.error("Failed to load local sheet", error);
        }
      }

      function scheduleSave() {
        if (isRemoteUpdate) return;
        if (saveTimer) clearTimeout(saveTimer);
        saveTimer = setTimeout(async () => {
          const payload = buildSheetPayload();
          saveLocalSheet(payload);
          try {
            await setDoc(sheetRef, payload, { merge: true });
          } catch (error) {
            console.error("Failed to save sheet", error);
          }
        }, 300);
      }

      function renderRoll(data) {
        if (!data) {
          resultEl.textContent = "No rolls yet.";
          return;
        }
        if (stickyRollEl) {
          stickyRollEl.classList.remove("banished");
          if (rollWindowHideTimer) clearTimeout(rollWindowHideTimer);
          rollWindowHideTimer = setTimeout(() => {
            stickyRollEl.classList.add("banished");
          }, ROLL_WINDOW_HIDE_MS);
        }
        resultEl.innerHTML = "";
        const who = data.by || "someone";
        const when = data.at ? new Date(data.at.seconds * 1000) : null;
        const time = when
          ? when.toLocaleTimeString("en-US", { hour: "2-digit", minute: "2-digit" })
          : "now";
        if (data.type === "weaponAttack") {
          const header = document.createElement("div");
          header.textContent = `${data.label || "Weapon Attack"} (by ${who} at ${time})`;
          resultEl.appendChild(header);

          const attackLine = document.createElement("div");
          attackLine.className = "roll-line";
          const attackMod = Number(data.attackMod) || 0;
          const attackRoll = Number(data.attackRoll) || 0;
          const attackTotal = Number(data.attackTotal) || 0;
          attackLine.textContent = `Attack: d20 ${attackRoll} ${attackMod >= 0 ? "+" : ""}${attackMod} = ${attackTotal}`;
          resultEl.appendChild(attackLine);

          const damageLine = document.createElement("div");
          damageLine.className = "roll-line";
          const damageMod = Number(data.damageMod) || 0;
          const damageBase = Number(data.damageBase) || 0;
          const damageMultiplier = Math.max(1, Number(data.damageMultiplier) || 1);
          const damageDice = String(data.damageDice || "").trim();
          const damageType = String(data.damageType || "").trim();
          const damageDetail = String(data.damageDetail || "").trim();
          const damageLabel = damageType ? `${damageDice} ${damageType}` : damageDice;
          const detailText = damageDetail ? ` (${damageDetail})` : "";
          const baseDamageTotal = damageBase + damageMod;
          const finalDamageTotal = baseDamageTotal * damageMultiplier;
          damageLine.textContent = damageMultiplier > 1
            ? `Damage: ${damageLabel}${detailText} ${damageMod >= 0 ? "+" : ""}${damageMod} = ${baseDamageTotal} x${damageMultiplier}`
            : `Damage: ${damageLabel}${detailText} ${damageMod >= 0 ? "+" : ""}${damageMod} = ${baseDamageTotal}`;
          resultEl.appendChild(damageLine);

          const total = document.createElement("div");
          total.className = "roll-total";
          total.textContent = `Damage Total: ${Number(data.damageTotal) || finalDamageTotal}`;
          resultEl.appendChild(total);
          return;
        }
        if (Array.isArray(data.parts)) {
          const header = document.createElement("div");
          header.textContent = `${data.label} (by ${who} at ${time})`;
          resultEl.appendChild(header);
          data.parts.forEach((part) => {
            const line = document.createElement("div");
            line.className = "roll-line";
            const left = document.createElement("span");
            const detail = part.detail ? ` (${part.detail})` : "";
            left.textContent = `${part.label}${detail}`;
            const right = document.createElement("span");
            right.textContent = part.value >= 0 ? `+${part.value}` : `${part.value}`;
            line.appendChild(left);
            line.appendChild(right);
            resultEl.appendChild(line);
          });
          const total = document.createElement("div");
          total.className = "roll-total";
          total.textContent = `Total: ${data.value}`;
          resultEl.appendChild(total);
          return;
        }
        if (data.roll !== undefined && data.mod !== undefined) {
          const header = document.createElement("div");
          header.textContent = `${data.label} (by ${who} at ${time})`;
          resultEl.appendChild(header);
          const line = document.createElement("div");
          line.className = "roll-line";
          line.textContent = `d20: ${data.roll} ${data.mod >= 0 ? "+" : ""}${data.mod}`;
          resultEl.appendChild(line);
          const total = document.createElement("div");
          total.className = "roll-total";
          total.textContent = `Total: ${data.value}`;
          resultEl.appendChild(total);
          return;
        }
        resultEl.textContent = `Last roll: ${data.value} (by ${who} at ${time})`;
      }

      onSnapshot(rollRef, (snap) => {
        renderRoll(snap.data());
      });

      if (stickyRollEl) {
        if (rollWindowHideTimer) clearTimeout(rollWindowHideTimer);
        rollWindowHideTimer = setTimeout(() => {
          stickyRollEl.classList.add("banished");
        }, ROLL_WINDOW_HIDE_MS);
      }

      setStartupModalOpen(true);
      loadLocalSheet();

      onSnapshot(sheetRef, (snap) => {
        const data = snap.data();
        applySheetData(data);
        if (data) {
          saveLocalSheet(buildSheetPayload());
        }
      });

      fieldEls.forEach((el) => {
        const evt = el.type === "checkbox" ? "change" : "input";
        el.addEventListener(evt, scheduleSave);
      });
      if (speedInput) {
        if ("value" in speedInput) speedInput.addEventListener("input", () => {
          if (currentRaceSpeed === "" || currentRaceSpeed === undefined) return;
          const lockedValue = String(currentRaceSpeed);
          if (getListValue(speedInput) !== lockedValue) {
            setListValue(speedInput, lockedValue);
          }
        });
      }
      if (backgroundInput) {
        backgroundInput.addEventListener("input", () => {
          buildCantripPickerList(spellSearch?.value || "");
        });
      }
      Object.values(abilityScores).forEach((el) => {
        if (el && "value" in el) {
          el.addEventListener("input", recalcDerived);
        }
      });
      if (levelEl && "value" in levelEl) {
        levelEl.addEventListener("input", recalcDerived);
      }
      levelDecreaseBtn?.addEventListener("click", () => adjustLevel(-1));
      levelIncreaseBtn?.addEventListener("click", () => adjustLevel(1));
      document.querySelectorAll(".list-item input[type='checkbox']").forEach((el) =>
        el.addEventListener("change", recalcDerived)
      );
      applyBaseDefaults();
      recalcDerived();
      async function initApp() {
        await loadWeapons();
        await loadArmors();
        await loadItems();
        await loadCantrips();
        await loadSpellLevel1FromFirestore();
        await loadSpellLevel2FromFirestore();
        await loadSpellLevel3FromFirestore();
        await loadTraits();
        await loadFeatsFromFirestore();
        await loadRaces();
        await loadBackgrounds();
        await loadClasses();
        await loadClassLevelUpData();
        initEquipmentWeapons();
        initItemPicker();
        initRacePicker();
        initBackgroundPicker();
        initSizePicker();
        initSpellPicker();
        initFeatPicker();
        initFeatChoicePicker();
        initAlignmentPicker();
        initAbilityPicker();
        initClassPicker();
        renderEquipment();
        renderInventoryItems();
        renderSpellSlotSquares();
        applyRaceSelection(raceInput?.value || "");
        if (classInput?.value) {
          const entry = classByName.get(classInput.value);
          if (entry) {
            applyClassSelection(entry, { rollHp: false });
          }
        }
        syncClassLevelProgressionForCurrentCharacter({ force: true });
      }
      initApp();
      startupNewCharacterBtn?.addEventListener("click", async () => {
        await startNewCharacter();
        setStartupModalOpen(false);
        openAbilityPickerForNewCharacter();
      });
      startupLoadCharacterBtn?.addEventListener("click", () => {
        setStartupModalOpen(false);
      });

      if (rollBtn) {
        rollBtn.addEventListener("click", async () => {
          const value = Math.floor(Math.random() * 20) + 1;
          playDiceSound();
          resultEl.textContent = `Rolling... (${value})`;
          try {
            await setDoc(rollRef, {
              value,
              by: "anonymous",
              at: serverTimestamp(),
            });
          } catch (error) {
            resultEl.textContent = "Failed to roll. Check Firestore permissions.";
            console.error(error);
          }
        });
      }

      function rollD20WithParts(parts, label, onDiceEnded = null) {
        const roll = Math.floor(Math.random() * 20) + 1;
        playDiceSound(onDiceEnded);
        const total = floorRollTotal(parts.reduce((sum, part) => sum + part.value, roll));
        const localData = {
          roll,
          value: total,
          label,
          parts: [
            { label: "d20", value: roll },
            ...parts,
          ],
          by: "you",
          at: { seconds: Math.floor(Date.now() / 1000) },
        };
        renderRoll(localData);
        return setDoc(rollRef, {
          roll,
          value: total,
          label,
          parts: [
            { label: "d20", value: roll },
            ...parts,
          ],
          by: "anonymous",
          at: serverTimestamp(),
        }).catch((error) => {
          console.error("Failed to save roll", error);
        });
      }

      function setupRollables() {
        function isInteractiveTarget(target) {
          if (!(target instanceof HTMLElement)) return false;
          if (target.closest("input[type='checkbox']")) return true;
          if (target instanceof HTMLButtonElement) return true;
          if (target instanceof HTMLSelectElement) return true;
          if (target instanceof HTMLTextAreaElement) return true;
          if (target instanceof HTMLInputElement) {
            return !target.readOnly;
          }
          return false;
        }

        function bindKey(el, handler) {
          el.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              handler();
            }
          });
        }

        function bindRowRoll(row, handler) {
          row.classList.add("rollable-row");
          row.setAttribute("role", "button");
          row.setAttribute("tabindex", "0");
          row.addEventListener("click", (event) => {
            if (isInteractiveTarget(event.target)) return;
            handler();
          });
          bindKey(row, handler);
        }

        saveRows.forEach((row) => {
          const ability = row.dataset.ability;
          const label = row.querySelector("span");
          const checkbox = row.querySelector("input[type='checkbox']");
          const name = label?.textContent || `${ability.toUpperCase()} Save`;
          if (label) {
            label.classList.add("rollable");
          }
          const handler = () => {
            const base = computeAbilityMod(toNumber(getListValue(abilityScores[ability])));
            const mod = base + (checkbox?.checked ? toNumber(proficiencyBonusEl?.value) : 0);
            const parts = [{ label: `${ability.toUpperCase()} Mod`, value: base }];
            if (checkbox?.checked) {
              parts.push({ label: "Proficiency", value: toNumber(proficiencyBonusEl?.value) });
            }
            rollD20WithParts(parts, `${name} Save`);
          };
          bindRowRoll(row, handler);
          if (label) {
            label.addEventListener("click", (event) => {
              event.stopPropagation();
              handler();
            });
            bindKey(label, handler);
          }
        });

        skillRows.forEach((row) => {
          const ability = row.dataset.ability;
          const label = row.querySelector("span");
          const checkbox = row.querySelector("input[type='checkbox']");
          const name = label?.textContent || "Skill Check";
          if (label) {
            label.classList.add("rollable");
          }
          const handler = () => {
            const base = computeAbilityMod(toNumber(getListValue(abilityScores[ability])));
            const mod = base + (checkbox?.checked ? toNumber(proficiencyBonusEl?.value) : 0);
            const parts = [{ label: `${ability.toUpperCase()} Mod`, value: base }];
            if (checkbox?.checked) {
              parts.push({ label: "Proficiency", value: toNumber(proficiencyBonusEl?.value) });
            }
            rollD20WithParts(parts, `${name} Check`);
          };
          bindRowRoll(row, handler);
          if (label) {
            label.addEventListener("click", (event) => {
              event.stopPropagation();
              handler();
            });
            bindKey(label, handler);
          }
          if (checkbox) {
            checkbox.addEventListener("change", handler);
          }
        });
      }

      function setupAttackRoll() {
        if (!attackRollBtn) return;
        attackRollBtn.addEventListener("click", (event) => {
          event.preventDefault();
          try {
            const mainItem = getEquippedWeaponById(equippedMainId);
            if (!mainItem) {
              setEquipStatus("Equip a main weapon before rolling hit.");
              return;
            }
            const weaponName = mainItem.name;
            const weapon = weaponName ? getWeaponData(weaponName) : null;
            const ability = getWeaponAttackAbility(weapon);
            const abilityKey = ability === "finesse"
              ? (toNumber(getListValue(abilityMods.dex)) >= toNumber(getListValue(abilityMods.str)) ? "dex" : "str")
              : ability || "str";
            const abilityValue = toNumber(getListValue(abilityMods[abilityKey]));
            const attackBonusParts = [{ label: `${abilityKey.toUpperCase()} Mod`, value: abilityValue }];
            if (weapon && isWeaponProficient(weapon)) {
              attackBonusParts.push({ label: "Proficiency", value: toNumber(proficiencyBonusEl?.value) });
            }
            const attackMod = attackBonusParts.reduce((sum, part) => sum + (Number(part.value) || 0), 0);
            const attackRoll = Math.floor(Math.random() * 20) + 1;
            const attackTotal = floorRollTotal(attackRoll + attackMod);
            const isCritical = attackRoll === 20;

            const useTwoHands =
              mainItem.id === equippedMainId && equippedMainTwoHanded && isVersatileWeapon(weapon);
            const damageDice = getWeaponDamageDie(weapon, useTwoHands);
            if (!damageDice) {
              setEquipStatus("This weapon has no damage dice configured.");
              return;
            }
            const damageType = String(weapon.damage || "").split(" ").slice(1).join(" ").trim();
            const damageDetail = rollDiceDetailed(damageDice);
            const damageBase = Number(damageDetail.total) || 0;
            const damageMod = abilityValue;
            const damageMultiplier = isCritical ? 2 : 1;
            const damageTotal = floorRollTotal((damageBase + damageMod) * damageMultiplier);

            playDiceSound(playWeaponSound);

            const label = weaponName ? `${weaponName} Attack` : "Weapon Attack";
            const localData = {
              type: "weaponAttack",
              label,
              attackRoll,
              attackMod,
              attackTotal,
              damageDice,
              damageType,
              damageDetail: Array.isArray(damageDetail.rolls) ? damageDetail.rolls.join("+") : "",
              damageBase,
              damageMod,
              damageMultiplier,
              damageTotal,
              isCritical,
              by: "you",
              at: { seconds: Math.floor(Date.now() / 1000) },
            };
            renderRoll(localData);
            setDoc(rollRef, {
              ...localData,
              by: "anonymous",
              at: serverTimestamp(),
            }).catch((error) => {
              console.error("Failed to save attack roll", error);
            });
          } catch (error) {
            console.error("Failed to roll attack", error);
          }
        });
      }

      function getSpellAttackAbilityKey() {
        const className = String(classInput?.value || "").trim();
        const classEntry = classByName.get(className);
        const primaryAbilities = Array.isArray(classEntry?.primaryAbility)
          ? classEntry.primaryAbility
          : [];
        for (const ability of primaryAbilities) {
          const key = normalizeAbilityKey(ability);
          if (key) return key;
        }
        const spellKeys = ["int", "wis", "cha"];
        return spellKeys.reduce((best, key) => (
          toNumber(getListValue(abilityMods[key])) > toNumber(getListValue(abilityMods[best])) ? key : best
        ), "int");
      }

      function rollSpellAttack(spellName) {
        const abilityKey = getSpellAttackAbilityKey();
        const abilityValue = toNumber(getListValue(abilityMods[abilityKey]));
        const parts = [{ label: `${abilityKey.toUpperCase()} Mod`, value: abilityValue }];
        parts.push({ label: "Proficiency", value: toNumber(proficiencyBonusEl?.value) });
        const label = spellName ? `${spellName} Spell Attack` : "Spell Attack";
        rollD20WithParts(parts, label, playSpellCastSound);
      }

      function buildSpellBaseDice(spell) {
        const count = Number(spell?.damageDiceCount) || 0;
        const die = String(spell?.damageDie || "").trim().toLowerCase();
        if (count > 0 && /^d\d+$/i.test(die)) {
          return `${count}${die}`;
        }
        return "";
      }

      function getSpellRollDice(spell) {
        const level = Math.max(1, toNumber(getListValue(levelEl)) || 1);
        const upgrades = [
          { minLevel: 17, dice: String(spell?.cantripUpgradeDice17 || "").trim() },
          { minLevel: 11, dice: String(spell?.cantripUpgradeDice11 || "").trim() },
          { minLevel: 5, dice: String(spell?.cantripUpgradeDice5 || "").trim() },
        ];
        for (const upgrade of upgrades) {
          if (level >= upgrade.minLevel && /^(\d+d\d+|\d+)$/i.test(upgrade.dice)) {
            return upgrade.dice;
          }
        }
        return buildSpellBaseDice(spell);
      }

      function rollSpellDamage(spell) {
        const dice = getSpellRollDice(spell);
        if (!dice) {
          resultEl.textContent = "This spell has no rollable damage dice.";
          return;
        }
        const detail = rollDiceDetailed(dice);
        playDiceSound(playSpellCastSound);
        const spellName = spell?.name || "Spell";
        const damageType = String(spell?.damageType || "").trim();
        const label = `${spellName} Damage`;
        const partLabel = damageType ? `${dice} ${damageType}` : dice;
        const localData = {
          roll: detail.total,
          value: floorRollTotal(detail.total),
          label,
          parts: [{ label: partLabel, value: detail.total, detail: detail.rolls.join("+") }],
          by: "you",
          at: { seconds: Math.floor(Date.now() / 1000) },
        };
        renderRoll(localData);
        setDoc(rollRef, {
          roll: detail.total,
          value: floorRollTotal(detail.total),
          label,
          parts: [{ label: partLabel, value: detail.total, detail: detail.rolls.join("+") }],
          by: "anonymous",
          at: serverTimestamp(),
        }).catch((error) => {
          console.error("Failed to save spell damage roll", error);
        });
      }

      function setupSpellAttackRoll() {
        if (!spellAttackRollBtn) return;
        spellAttackRollBtn.addEventListener("click", (event) => {
          event.preventDefault();
          rollSpellAttack();
        });
      }

      function setupInitiativeRoll() {
        if (!initiativeEl) return;
        const rollInitiative = () => {
          const dexMod = toNumber(getListValue(abilityMods.dex));
          const parts = [{ label: "DEX Mod", value: dexMod }];
          rollD20WithParts(parts, "Initiative");
        };
        initiativeEl.addEventListener("click", (event) => {
          event.preventDefault();
          rollInitiative();
        });
        initiativeEl.addEventListener("keydown", (event) => {
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            rollInitiative();
          }
        });
      }

      function openItemPanel(name) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody) return;
        const armor = getArmorData(name);
        if (armor) {
          itemPanelTitle.textContent = armor.name;
          itemPanelBody.innerHTML = "";
          const dexPart =
            armor.dexBonus?.allowed
              ? armor.dexBonus?.max === null
                ? "+ DEX"
                : `+ DEX (max ${armor.dexBonus.max})`
              : "--";
        const rows = [
            ["Type", armor.type || "--"],
            ["AC", `${armor.baseAC || 0} ${dexPart}`.trim()],
            ["Strength Requirement", armor.strengthRequirement || "--"],
            ["Stealth", armor.stealthDisadvantage ? "Disadvantage" : "Normal"],
            ["Weight", armor.weightLb !== null && armor.weightLb !== undefined ? `${armor.weightLb} lb.` : "--"],
            ["Cost", armor.costGp !== null && armor.costGp !== undefined ? `${armor.costGp} gp` : "--"],
            ["Don Time", armor.donTimeMinutes !== null && armor.donTimeMinutes !== undefined ? `${armor.donTimeMinutes} min` : "--"],
            ["Doff Time", armor.doffTimeMinutes !== null && armor.doffTimeMinutes !== undefined ? `${armor.doffTimeMinutes} min` : "--"],
          ];
          rows.forEach(([label, value]) => {
            const row = document.createElement("div");
            row.className = "item-row";
            const strong = document.createElement("strong");
            strong.textContent = label;
            const val = document.createElement("div");
            val.textContent = value;
            val.className = "item-tooltip";
            val.setAttribute("data-tooltip", `${label}: ${value}`);
            row.appendChild(strong);
            row.appendChild(val);
            itemPanelBody.appendChild(row);
          });
          itemPanel.classList.add("open");
          itemPanel.setAttribute("aria-hidden", "false");
          return;
        }
        const weapon = getWeaponData(name);
        if (!weapon) return;
        const useTwoHands =
          weapon.name === getEquippedWeaponById(equippedMainId)?.name && equippedMainTwoHanded;
        const damageValue = useTwoHands
          ? `${getWeaponDamageDie(weapon, true)} ${weapon.damage.split(" ").slice(1).join(" ")}`
          : weapon.damage;
        const [dice, ...typeParts] = (damageValue || "").split(" ");
        const damageType = typeParts.join(" ");
        const ability = getWeaponAttackAbility(weapon);
        const abilityLabel =
          ability === "finesse" ? "Finesse (STR/DEX)" : ability.toUpperCase();
        const rangeMatch = weapon.properties.match(/Range\\s*([0-9/]+)/i);
        const rangeValue = rangeMatch ? rangeMatch[1] : null;
        itemPanelTitle.textContent = weapon.name;
        itemPanelBody.innerHTML = "";
        const rows = [
          ["Category", weapon.category.replace(" Weapons", "")],
          ["Type", weapon.category.includes("Ranged") ? "Ranged" : "Melee"],
          ["Damage", dice || ""],
          ["Damage Type", damageType || ""],
          ["Attack Ability", abilityLabel],
          ["Properties", weapon.properties === "" ? "None" : weapon.properties],
          ["Mastery", weapon.mastery || ""],
          ["Weight", weapon.weight || ""],
          ["Cost", weapon.cost || ""],
        ];
        if (rangeValue) {
          rows.splice(4, 0, ["Range", rangeValue]);
        }
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", getItemTooltip(label, value, weapon));
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function openSpellPanel(spell) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !spell) return;
        itemPanelTitle.textContent = spell.name || "Spell";
        itemPanelBody.innerHTML = "";
        const levelLabel = formatSpellLevel(spell.level);
        const savingThrowText = Array.isArray(spell.savingThrows) && spell.savingThrows.length
          ? spell.savingThrows.join(", ")
          : "--";
        const rows = [
          ["Level", levelLabel || "--"],
          ["School", spell.school || "--"],
          ["Range", spell.range || "--"],
          ["Components", spell.components || "--"],
          ["Saving Throw", savingThrowText],
          ["Duration", spell.duration || "--"],
          ["Classes", (spell.classes || []).join(", ") || "--"],
          ["Description", spell.description || "--"],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", getSpellTooltip(label, value));
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function getClassTooltip(label, value) {
        if (label === "Subclasses") {
          return Array.isArray(value) && value.length
            ? `Subclasses: ${value.join(", ")}.`
            : "No subclasses listed.";
        }
        if (label === "Description") {
          return value || "No description.";
        }
        return `${label}: ${value || "--"}`;
      }

      function openClassPanel(entry) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !entry) return;
        itemPanelTitle.textContent = entry.name || "Class";
        itemPanelBody.innerHTML = "";
        const subclassNames = entry.subclasses.map((sub) => sub.name).filter(Boolean);
        const equipmentOptionsSummary = Array.isArray(entry.startingEquipment)
          ? entry.startingEquipment
              .map((line, idx) => {
                const parsed = parseClassEquipmentLine(line);
                if (parsed.type === "choice" && parsed.options.length) {
                  return `${idx + 1}. ${parsed.options.join(" OR ")}`;
                }
                return `${idx + 1}. ${parsed.value || "--"}`;
              })
              .join("\n")
          : "--";
        const rows = [
          ["Description", entry.description || "--"],
          ["Primary Ability", entry.primaryAbility.join(", ") || "--"],
          ["Hit Die", entry.hitPointDie || "--"],
          ["Hit Die Modifier", entry.hitPointDieModifier || "--"],
          ["HP per Level", entry.hitPointPerAdditionalLevelDie || "--"],
          ["Saving Throws", entry.savingThrows.join(", ") || "--"],
          ["Weapon Proficiencies", entry.weaponProficiencies.join(", ") || "--"],
          ["Armor Training", entry.armorTraining.join(", ") || "--"],
          ["Starting Equipment", equipmentOptionsSummary],
          ["Subclasses", subclassNames.join(", ") || "--"],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", getClassTooltip(label, label === "Subclasses" ? subclassNames : value));
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function getRaceTooltip(label, value) {
        if (label === "Traits") {
          return Array.isArray(value) && value.length
            ? `Traits: ${value.join(", ")}.`
            : "No traits listed.";
        }
        if (label === "Description") {
          return value || "No description.";
        }
        return `${label}: ${value || "--"}`;
      }

      function getBackgroundTooltip(label, value) {
        if (label === "Ability") {
          return value || "No ability options.";
        }
        if (label === "Feat") {
          return value || "No feat listed.";
        }
        if (label === "Skills") {
          return value || "No skills listed.";
        }
        if (label === "Tools") {
          return value || "No tools listed.";
        }
        if (label === "Equipment") {
          return value || "No equipment listed.";
        }
        return `${label}: ${value || "--"}`;
      }

      function openBackgroundPanel(entry) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !entry) return;
        itemPanelTitle.textContent = entry.name || "Background";
        itemPanelBody.innerHTML = "";
        const abilityModes = getBackgroundAbilityModes(entry)
          .map((mode) => mode.weights.map((weight) => `+${weight}`).join(" / "))
          .join(" or ");
        const feats = extractBackgroundFeatNames(entry);
        const skills = extractBackgroundSkillNames(entry);
        const tools = extractBackgroundToolNames(entry);
        const equipSet = entry.startingEquipment?.[0] || {};
        const equipRows = Object.keys(equipSet).map(
          (key) => `${key}: ${summarizeEquipmentChoice(equipSet[key] || [])}`
        );
        const rows = [
          ["Ability", abilityModes || "--"],
          ["Feat", feats.join(", ") || "--"],
          ["Skills", skills.join(", ") || "--"],
          ["Tools", tools.join(", ") || "--"],
          ["Equipment", equipRows.join(" | ") || "--"],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", getBackgroundTooltip(label, value));
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function openRacePanel(entry) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !entry) return;
        itemPanelTitle.textContent = entry.name || "Race";
        itemPanelBody.innerHTML = "";
        const sizes = normalizeRaceSizes(entry.size);
        const traits = Array.isArray(entry.traits) ? entry.traits.slice() : [];
        const types = Array.isArray(entry.creatureType) ? entry.creatureType.slice() : [];
        const subclasses = Array.isArray(entry.subclass) ? entry.subclass.slice() : [];
        const rows = [
          ["Description", entry.description || "--"],
          ["Creature Type", types.join(", ") || "--"],
          ["Size", sizes.join(", ") || "--"],
          ["Speed", normalizeRaceSpeed(entry.speed) !== "" ? String(entry.speed) : "--"],
          ["Traits", traits.join(", ") || "--"],
          ["Subraces", subclasses.join(", ") || "--"],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          const tooltipValue = label === "Traits" ? traits : value;
          val.setAttribute("data-tooltip", getRaceTooltip(label, tooltipValue));
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function setupItemPanel() {
        if (!itemPanel || !itemPanelClose) return;
        itemPanelClose.addEventListener("click", (event) => {
          event.stopPropagation();
          itemPanel.classList.remove("open");
          itemPanel.setAttribute("aria-hidden", "true");
        });
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            itemPanel.classList.remove("open");
            itemPanel.setAttribute("aria-hidden", "true");
          }
        });
      }

      setupRollables();
      setupAttackRoll();
      setupSpellAttackRoll();
      setupInitiativeRoll();
      setupItemPanel();
      console.log("Firebase initialized", app.name);
    </script>
  </body>
</html>




